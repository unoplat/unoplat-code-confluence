[{"NodeName":"ArchGuardHandler","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/codebaseparser/arc_guard_handler.py","Functions":[{"Name":"__init__","Parameters":[{"TypeValue":"jar_path","TypeType":""},{"TypeValue":"language","TypeType":""},{"TypeValue":"codebase_path","TypeType":""},{"TypeValue":"codebase_name","TypeType":""},{"TypeValue":"output_path","TypeType":""},{"TypeValue":"extension","TypeType":"str"}],"FunctionCalls":[{"FunctionName":"TotalFileCount","Position":{"StartLine":23,"StartLinePosition":42,"StopLine":23,"StopLinePosition":83}}],"Position":{"StartLine":13,"StartLinePosition":4,"StopLine":25,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"self.jar_path","TypeType":"jar_path"},{"TypeValue":"self.language","TypeType":"language"},{"TypeValue":"self.codebase_path","TypeType":"codebase_path"},{"TypeValue":"self.output_path","TypeType":"output_path"},{"TypeValue":"self.total_files","TypeType":"0"},{"TypeValue":"self.current_file_count","TypeType":"0"},{"TypeValue":"self.codebase_name","TypeType":"codebase_name"},{"TypeValue":"self.extension","TypeType":"extension"},{"TypeValue":"self.file_counter","TypeType":"TotalFileCount"}],"Content":"def __init__(self, jar_path, language, codebase_path,codebase_name, output_path,extension:str):        self.jar_path = jar_path        self.language = language        self.codebase_path = codebase_path        self.output_path = output_path        self.total_files = 0        self.current_file_count = 0        self.codebase_name = codebase_name        self.extension  = extension        # Initialize FileCounter in the constructor        self.file_counter = TotalFileCount(self.codebase_path, f'.{self.extension}')    "},{"Name":"run_scan","FunctionCalls":[{"NodeName":"logger","FunctionName":"info","Position":{"StartLine":60,"StartLinePosition":14,"StopLine":60,"StopLinePosition":62}}],"Position":{"StartLine":25,"StartLinePosition":4,"StopLine":64,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"self.jar_path","TypeType":"jar_path"},{"TypeValue":"self.language","TypeType":"language"},{"TypeValue":"self.codebase_path","TypeType":"codebase_path"},{"TypeValue":"self.output_path","TypeType":"output_path"},{"TypeValue":"self.total_files","TypeType":"self"},{"TypeValue":"self.current_file_count","TypeType":"0"},{"TypeValue":"self.codebase_name","TypeType":"codebase_name"},{"TypeValue":"self.extension","TypeType":"extension"},{"TypeValue":"self.file_counter","TypeType":"TotalFileCount"},{"TypeValue":"command","TypeType":"[\"java\",\"-jar\",self.jar_path,\"--with-function-code\",f\"--language={self.language}\",\"--output=arrow\",\"--output=json\",f\"--path={self.codebase_path}\",f\"--output-dir={self.output_path}\"]"},{"TypeValue":"process","TypeType":"subprocess"},{"TypeValue":"output","TypeType":"process"},{"TypeValue":"progress_value","TypeType":"self"},{"TypeValue":"","TypeType":"process"},{"TypeValue":"chapi_metadata_path","TypeType":"self"}],"Content":"def run_scan(self) -> str:        # Get total number of files in run_scan        self.total_files = self.file_counter.count_files()        logger.info(\"Starting scan...\")        command = [            \"java\", \"-jar\", self.jar_path,            \"--with-function-code\",            f\"--language={self.language}\",            \"--output=arrow\", \"--output=json\",            f\"--path={self.codebase_path}\",            f\"--output-dir={self.output_path}\"        ]        logger.info(f\"Command: {' '.join(command)}\")                process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)        while True:            output = process.stdout.readline()            logger.debug(output)            if output == '' and process.poll() is not None:                break            if output:                logger.info(output.strip())                progress_value = self.parse_progress(output, total_files=self.total_files)                logger.info(f\"Progress: {progress_value}%\")        stdout, stderr = process.communicate()        if process.returncode == 0:            logger.info(\"Scan completed successfully\")            chapi_metadata_path = self.modify_output_filename(\"0_codes.json\", f\"{self.codebase_name}_codes.json\")        else:            logger.error(f\"Error in scanning: {stderr}\")        logger.info(f\"Total files scanned: {self.total_files}\")        return chapi_metadata_path    "},{"Name":"parse_progress","Parameters":[{"TypeValue":"output","TypeType":""},{"TypeValue":"total_files","TypeType":""}],"Position":{"StartLine":64,"StartLinePosition":4,"StopLine":74,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"self.jar_path","TypeType":"jar_path"},{"TypeValue":"self.language","TypeType":"language"},{"TypeValue":"self.codebase_path","TypeType":"codebase_path"},{"TypeValue":"self.output_path","TypeType":"output_path"},{"TypeValue":"self.total_files","TypeType":"self"},{"TypeValue":"self.current_file_count","TypeType":""},{"TypeValue":"self.codebase_name","TypeType":"codebase_name"},{"TypeValue":"self.extension","TypeType":"extension"},{"TypeValue":"self.file_counter","TypeType":"TotalFileCount"},{"TypeValue":"command","TypeType":"[\"java\",\"-jar\",self.jar_path,\"--with-function-code\",f\"--language={self.language}\",\"--output=arrow\",\"--output=json\",f\"--path={self.codebase_path}\",f\"--output-dir={self.output_path}\"]"},{"TypeValue":"process","TypeType":"subprocess"},{"TypeValue":"output","TypeType":"process"},{"TypeValue":"progress_value","TypeType":"self"},{"TypeValue":"","TypeType":"process"},{"TypeValue":"chapi_metadata_path","TypeType":"self"},{"TypeValue":"progress_percentage","TypeType":""}],"Content":"def parse_progress(self, output, total_files):        if total_files == 0:            return 0        else:            if \"analysis file\" in output:                self.current_file_count += 1            progress_percentage = (self.current_file_count / total_files) * 100                        return int(progress_percentage)            "},{"Name":"modify_output_filename","Parameters":[{"TypeValue":"old_filename","TypeType":""},{"TypeValue":"new_filename","TypeType":""}],"FunctionCalls":[{"NodeName":"os","FunctionName":"rename","Position":{"StartLine":78,"StartLinePosition":10,"StopLine":78,"StopLinePosition":46}}],"Position":{"StartLine":74,"StartLinePosition":4,"StopLine":81},"LocalVariables":[{"TypeValue":"self.jar_path","TypeType":"jar_path"},{"TypeValue":"self.language","TypeType":"language"},{"TypeValue":"self.codebase_path","TypeType":"codebase_path"},{"TypeValue":"self.output_path","TypeType":"output_path"},{"TypeValue":"self.total_files","TypeType":"self"},{"TypeValue":"self.current_file_count","TypeType":""},{"TypeValue":"self.codebase_name","TypeType":"codebase_name"},{"TypeValue":"self.extension","TypeType":"extension"},{"TypeValue":"self.file_counter","TypeType":"TotalFileCount"},{"TypeValue":"command","TypeType":"[\"java\",\"-jar\",self.jar_path,\"--with-function-code\",f\"--language={self.language}\",\"--output=arrow\",\"--output=json\",f\"--path={self.codebase_path}\",f\"--output-dir={self.output_path}\"]"},{"TypeValue":"process","TypeType":"subprocess"},{"TypeValue":"output","TypeType":"process"},{"TypeValue":"progress_value","TypeType":"self"},{"TypeValue":"","TypeType":"process"},{"TypeValue":"chapi_metadata_path","TypeType":"self"},{"TypeValue":"progress_percentage","TypeType":""},{"TypeValue":"current_directory","TypeType":"os"},{"TypeValue":"old_file_path","TypeType":"os"},{"TypeValue":"new_file_path","TypeType":"os"}],"Content":"def modify_output_filename(self, old_filename, new_filename) -> str:        current_directory = os.getcwd()        old_file_path = os.path.join(current_directory, old_filename)        new_file_path = os.path.join(current_directory, new_filename)        os.rename(old_file_path, new_file_path)        return new_file_path"}],"Imports":[{"Source":"os"},{"Source":"subprocess"},{"Source":"loguru","UsageName":["logger"]},{"Source":"unoplat_code_confluence.utility.total_file_count","UsageName":["TotalFileCount"]}],"Position":{"StartLine":12,"StopLine":81},"Content":"class ArchGuardHandler:    def __init__(self, jar_path, language, codebase_path,codebase_name, output_path,extension:str):        self.jar_path = jar_path        self.language = language        self.codebase_path = codebase_path        self.output_path = output_path        self.total_files = 0        self.current_file_count = 0        self.codebase_name = codebase_name        self.extension  = extension        # Initialize FileCounter in the constructor        self.file_counter = TotalFileCount(self.codebase_path, f'.{self.extension}')    def run_scan(self) -> str:        # Get total number of files in run_scan        self.total_files = self.file_counter.count_files()        logger.info(\"Starting scan...\")        command = [            \"java\", \"-jar\", self.jar_path,            \"--with-function-code\",            f\"--language={self.language}\",            \"--output=arrow\", \"--output=json\",            f\"--path={self.codebase_path}\",            f\"--output-dir={self.output_path}\"        ]        logger.info(f\"Command: {' '.join(command)}\")                process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)        while True:            output = process.stdout.readline()            logger.debug(output)            if output == '' and process.poll() is not None:                break            if output:                logger.info(output.strip())                progress_value = self.parse_progress(output, total_files=self.total_files)                logger.info(f\"Progress: {progress_value}%\")        stdout, stderr = process.communicate()        if process.returncode == 0:            logger.info(\"Scan completed successfully\")            chapi_metadata_path = self.modify_output_filename(\"0_codes.json\", f\"{self.codebase_name}_codes.json\")        else:            logger.error(f\"Error in scanning: {stderr}\")        logger.info(f\"Total files scanned: {self.total_files}\")        return chapi_metadata_path    def parse_progress(self, output, total_files):        if total_files == 0:            return 0        else:            if \"analysis file\" in output:                self.current_file_count += 1            progress_percentage = (self.current_file_count / total_files) * 100                        return int(progress_percentage)            def modify_output_filename(self, old_filename, new_filename) -> str:        current_directory = os.getcwd()        old_file_path = os.path.join(current_directory, old_filename)        new_file_path = os.path.join(current_directory, new_filename)        os.rename(old_file_path, new_file_path)        return new_file_path"},{"NodeName":"DspyUnoplatCodebaseSummary","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/data_models/dspy/dspy_unoplat_codebase_summary.py","MultipleExtend":["BaseModel"],"Imports":[{"Source":"typing","UsageName":["Dict","Optional"]},{"Source":"pydantic","UsageName":["BaseModel","Field"]},{"Source":"unoplat_code_confluence.data_models.dspy.dspy_unoplat_package_summary","UsageName":["DspyUnoplatPackageSummary"]}],"Position":{"StartLine":11,"StopLine":16,"StopLinePosition":145},"Content":"class DspyUnoplatCodebaseSummary(BaseModel):    codebase_summary: Optional[str] = Field(default=None, description=\"A summary of the codebase\")    codebase_objective: Optional[str] = Field(default=None, description=\"The objective of the codebase\")    metadata: Optional[dict] = Field(default=None, description=\"The metadata of the codebase\")    codebase_name: Optional[str] = Field( default=None,description=\"The file id of the codebase summary\")    codebase_package: Optional[Dict[str,DspyUnoplatPackageSummary]] = Field(default_factory=dict,description=\"A summary of the codebase package\")"},{"NodeName":"DspyUnoplatFunctionSummary","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/data_models/dspy/dspy_unoplat_function_summary.py","MultipleExtend":["ChapiUnoplatFunction"],"Imports":[{"Source":"typing","UsageName":["List","Optional"]},{"Source":"pydantic","UsageName":["Field"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_function","UsageName":["ChapiUnoplatFunction"]}],"Position":{"StartLine":11,"StopLine":18},"Content":"class DspyUnoplatFunctionSummary(ChapiUnoplatFunction):    qualified_name: str = Field(required=True, alias=\"QualifiedName\",description=\"The qualified name of the function that contains the entire hierarchy of the class\")    objective: Optional[str] = Field(default=None, alias=\"Objective\",description=\"This should include high level objective of what function does based on function content and function metadata. Should not be more than 3 lines.\")    implementation_summary: Optional[str] = Field(default=None, alias=\"ImplementationSummary\",description=\"This should include implementation details of the function. make sure if this function makes internal calls to other functions of same class and to external calls to other classes/libs is also covered. Use all metadata shared for the function to answer .\")    function_objective_embedding: List[float] = Field(default_factory=list, alias=\"FunctionObjectiveEmbedding\")    function_implementation_summary_embedding: List[float] = Field(default_factory=list, alias=\"FunctionImplementationSummaryEmbedding\")    "},{"NodeName":"DspyUnoplatNodeSummary","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/data_models/dspy/dspy_unoplat_node_summary.py","MultipleExtend":["ChapiUnoplatNode"],"Imports":[{"Source":"typing","UsageName":["List","Optional"]},{"Source":"pydantic","UsageName":["Field"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_node","UsageName":["ChapiUnoplatNode"]},{"Source":"unoplat_code_confluence.data_models.dspy.dspy_unoplat_function_summary","UsageName":["DspyUnoplatFunctionSummary"]}],"Position":{"StartLine":12,"StopLine":20,"StopLinePosition":4},"Content":"class DspyUnoplatNodeSummary(ChapiUnoplatNode):    qualified_name: str = Field(required=True, alias=\"QualifiedName\",description=\"The qualified name of the class that contains the entire hierarchy of the class\")    node_summary: str = Field(required=True, alias=\"NodeSummary\",description=\"A summary of the class\")    node_objective: str = Field(required=True, alias=\"NodeObjective\",description=\"The objective of the class\")    functions_summary: Optional[List[DspyUnoplatFunctionSummary]] = Field(default=None, alias=\"FunctionsSummary\",description=\"A list of functions in the class\")    class_objective_embedding: List[float] = Field(default_factory=list, alias=\"ClassObjectiveEmbedding\")    class_implementation_summary_embedding: List[float] = Field(default_factory=list, alias=\"ClassImplementationSummaryEmbedding\")        "},{"NodeName":"DspyUnoplatPackageSummary","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/data_models/dspy/dspy_unoplat_package_summary.py","MultipleExtend":["BaseModel"],"Imports":[{"Source":"typing","UsageName":["Dict","List","Optional"]},{"Source":"pydantic","UsageName":["BaseModel","Field"]},{"Source":"unoplat_code_confluence.data_models.dspy.dspy_unoplat_node_summary","UsageName":["DspyUnoplatNodeSummary"]}],"Position":{"StartLine":11,"StopLine":18},"Content":"class DspyUnoplatPackageSummary(BaseModel):    package_objective: str = Field( description=\"The objective of the package in a concise manner\")    package_summary: str = Field( description=\"The detailed summary of the package\")    class_summary: List[DspyUnoplatNodeSummary] = Field( default_factory=list,description=\"List of the class summaries for the package\")    metadata: Optional[dict] = Field(default=None, description=\"Additional metadata for the package\")    sub_package_summaries: Dict[str, 'DspyUnoplatPackageSummary'] = Field(default_factory=dict, description=\"Dictionary of sub-package summaries, keyed by package name\")    "},{"NodeName":"ChapiUnoplatAnnotationKeyVal","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/data_models/chapi_unoplat_annotation_key_val.py","MultipleExtend":["BaseModel"],"Imports":[{"Source":"typing","UsageName":["Optional"]},{"Source":"pydantic","UsageName":["BaseModel","Field"]}],"Position":{"StartLine":11,"StopLine":13,"StopLinePosition":99},"Content":"class ChapiUnoplatAnnotationKeyVal(BaseModel):    key: Optional[str] = Field(default=None, alias=\"Key\",description=\"Key of the annotation\")    value: Optional[str] = Field(default=None, alias=\"Value\",description=\"Value of the annotation\")"},{"NodeName":"ChapiUnoplatFunction","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/data_models/chapi_unoplat_function.py","MultipleExtend":["BaseModel"],"Imports":[{"Source":"typing","UsageName":["List","Optional"]},{"Source":"pydantic","UsageName":["BaseModel","Field"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_annotation","UsageName":["Annotation"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_functioncall","UsageName":["FunctionCall"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_position","UsageName":["Position"]},{"Source":"unoplat_code_confluence.data_models.unoplat_function_field_model","UsageName":["UnoplatFunctionFieldModel"]}],"Position":{"StartLine":14,"StopLine":23},"Content":"class ChapiUnoplatFunction(BaseModel):    name: Optional[str] = Field(default=None, alias=\"Name\")    return_type: Optional[str] = Field(default=None, alias=\"ReturnType\")    function_calls: List[FunctionCall] = Field(default_factory=list, alias=\"FunctionCalls\")    annotations: List[Annotation] = Field(default_factory=list, alias=\"Annotations\")    position: Optional[Position] = Field(default=None, alias=\"Position\",exclude=True)    local_variables: List[UnoplatFunctionFieldModel] = Field(default_factory=list, alias=\"LocalVariables\")    body_hash: Optional[int] = Field(default=None, alias=\"BodyHash\",exclude=True)    content: Optional[str] = Field(default=None, alias=\"Content\")"},{"NodeName":"Import","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/data_models/chapi_unoplat_import.py","MultipleExtend":["BaseModel"],"Imports":[{"Source":"typing","UsageName":["List","Optional"]},{"Source":"pydantic","UsageName":["BaseModel","Field"]}],"Position":{"StartLine":8,"StopLine":11},"Content":"class Import(BaseModel):    source: Optional[str] = Field(default=None, alias=\"Source\")    usage_name: List[str] = Field(default_factory=list, alias=\"UsageName\")"},{"NodeName":"ChapiUnoplatNode","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/data_models/chapi_unoplat_node.py","MultipleExtend":["BaseModel"],"Imports":[{"Source":"typing","UsageName":["List","Optional"]},{"Source":"pydantic","UsageName":["BaseModel","Field"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_annotation","UsageName":["Annotation"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_class_fieldmodel","UsageName":["ClassFieldModel"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_function","UsageName":["ChapiUnoplatFunction"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_import","UsageName":["Import"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_position","UsageName":["Position"]}],"Position":{"StartLine":15,"StopLine":29},"Content":"class ChapiUnoplatNode(BaseModel):    node_name: Optional[str] = Field(default=None, alias=\"NodeName\")    type: Optional[str] = Field(default=None, alias=\"Type\")    file_path: Optional[str] = Field(default=None, alias=\"FilePath\",exclude=True)    module: Optional[str] = Field(default=None, alias=\"Module\",exclude=True)    package: Optional[str] = Field(default=None, alias=\"Package\",exclude=True)    multiple_extend: Optional[list[str]] = Field(default_factory=list, alias=\"MultipleExtend\")    fields: List[ClassFieldModel] = Field(default_factory=list, alias=\"Fields\")    extend: Optional[str] = Field(default=None, alias=\"Extend\")    imports: List[Import] = Field(default_factory=list, alias=\"Imports\")    functions: List[ChapiUnoplatFunction] = Field(default_factory=list, alias=\"Functions\")    position: Optional[Position] = Field(default=None, alias=\"Position\",exclude=True)    content: Optional[str] = Field(default=None, alias=\"Content\",exclude=True)    annotations: List[Annotation] = Field(default_factory=list, alias=\"Annotations\")"},{"NodeName":"Position","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/data_models/chapi_unoplat_position.py","MultipleExtend":["BaseModel"],"Imports":[{"Source":"typing","UsageName":["Optional"]},{"Source":"pydantic","UsageName":["BaseModel","Field"]}],"Position":{"StartLine":9,"StopLine":13,"StopLinePosition":85},"Content":"class Position(BaseModel):    start_line: Optional[int] = Field(default=None, alias=\"StartLine\")    start_line_position: Optional[int] = Field(default=None, alias=\"StartLinePosition\")    stop_line: Optional[int] = Field(default=None, alias=\"StopLine\")    stop_line_position: Optional[int] = Field(default=None, alias=\"StopLinePosition\")"},{"NodeName":"Parameter","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/data_models/chapi_unoplat_parameter.py","MultipleExtend":["BaseModel"],"Imports":[{"Source":"typing","UsageName":["Optional"]},{"Source":"pydantic","UsageName":["BaseModel","Field"]}],"Position":{"StartLine":8,"StopLine":11},"Content":"class Parameter(BaseModel):    type_value: Optional[str] = Field(default=None, alias=\"TypeValue\")    type_type: Optional[str] = Field(default=None, alias=\"TypeType\")"},{"NodeName":"Annotation","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/data_models/chapi_unoplat_annotation.py","MultipleExtend":["BaseModel"],"Imports":[{"Source":"typing","UsageName":["Optional"]},{"Source":"pydantic","UsageName":["BaseModel","Field"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_annotation_key_val","UsageName":["ChapiUnoplatAnnotationKeyVal"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_position","UsageName":["Position"]}],"Position":{"StartLine":12,"StopLine":16},"Content":"class Annotation(BaseModel):    name: Optional[str] = Field(default=None, alias=\"Name\")    key_values: Optional[list[ChapiUnoplatAnnotationKeyVal]] = Field(default_factory=list, alias=\"KeyValues\")    position: Optional[Position] = Field(default=None, alias=\"Position\")"},{"NodeName":"UnoplatCodebase","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/data_models/chapi_unoplat_codebase.py","MultipleExtend":["BaseModel"],"Imports":[{"Source":"typing","UsageName":["Optional"]},{"Source":"pydantic","UsageName":["BaseModel","Field"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_package","UsageName":["UnoplatPackage"]}],"Position":{"StartLine":11,"StopLine":13,"StopLinePosition":4},"Content":"class UnoplatCodebase(BaseModel):    packages: Optional[UnoplatPackage] = Field(default=None, alias=\"UnoplatPackages\")    "},{"NodeName":"FunctionCall","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/data_models/chapi_unoplat_functioncall.py","MultipleExtend":["BaseModel"],"Imports":[{"Source":"typing","UsageName":["List","Optional"]},{"Source":"pydantic","UsageName":["BaseModel","Field"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_parameter","UsageName":["Parameter"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_position","UsageName":["Position"]}],"Position":{"StartLine":15,"StopLine":25,"StopLinePosition":1},"Content":"class FunctionCall(BaseModel):    \"\"\"    FunctionCall is a data model for a function call being made in a function.    \"\"\"    package: Optional[str] = Field(default=None, alias=\"Package\",description=\"package name of the function call\")    type: Optional[str] = Field(default=None, alias=\"Type\",description=\"type of the function call\")    node_name: Optional[str] = Field(default=None, alias=\"NodeName\",description=\"name of the class being called\")    function_name: Optional[str] = Field(default=None, alias=\"FunctionName\",description=\"name of the function being called\")    parameters: List[Parameter] = Field(default_factory=list, alias=\"Parameters\",description=\"parameters of the function call\")    position: Optional[Position] = Field(default=None, alias=\"Position\",exclude=True,description=\"position of the function call in the code\") "},{"NodeName":"ClassFieldModel","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/data_models/chapi_unoplat_class_fieldmodel.py","MultipleExtend":["BaseModel"],"Imports":[{"Source":"typing","UsageName":["List","Optional"]},{"Source":"pydantic","UsageName":["BaseModel","Field"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_annotation","UsageName":["Annotation"]}],"Position":{"StartLine":11,"StopLine":15},"Content":"class ClassFieldModel(BaseModel):    type_type: Optional[str] = Field(default=None, alias=\"TypeType\",description=\"Class Field Type\")    type_key: Optional[str] = Field(default=None, alias=\"TypeKey\",description=\"Class Field Name\")    annotations: Optional[List[Annotation]]= Field(default=None, alias=\"Annotations\",description=\"Class Field Annotation\")"},{"NodeName":"UnoplatFunctionFieldModel","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/data_models/unoplat_function_field_model.py","MultipleExtend":["BaseModel"],"Imports":[{"Source":"typing","UsageName":["Optional"]},{"Source":"pydantic","UsageName":["BaseModel","Field"]}],"Position":{"StartLine":8,"StopLine":11},"Content":"class UnoplatFunctionFieldModel(BaseModel):    type_value: Optional[str] = Field(default=None, alias=\"TypeValue\",description=\"function field name\")    type_type: Optional[str] = Field(default=None, alias=\"TypeType\",description=\"function field type. Can be incorrect sometime if variable is returned without declaration. So refer content attribute too to understand better.\")"},{"NodeName":"UnoplatPackage","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/data_models/chapi_unoplat_package.py","MultipleExtend":["BaseModel"],"Imports":[{"Source":"typing","UsageName":["Dict","List","Optional"]},{"Source":"pydantic","UsageName":["BaseModel","Field"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_node","UsageName":["ChapiUnoplatNode"]}],"Position":{"StartLine":11,"StopLine":16},"Content":"class UnoplatPackage(BaseModel):    name: Optional[str] = Field(default=None,description=\"Name of the package\")    nodes: Optional[List[ChapiUnoplatNode]] = Field( default_factory=list,description=\"List of the nodes for the package\")    sub_packages: Optional[Dict[str, 'UnoplatPackage']] = Field( default_factory=dict,description=\"Dict of the sub-packages for the package\")"},{"NodeName":"UnoplatGraphIngestion","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/database/graph/unoplat_graph_ingestion.py","Functions":[{"Name":"__init__","Parameters":[{"TypeValue":"app_config","TypeType":"AppConfig"}],"FunctionCalls":[{"NodeName":"db","FunctionName":"set_connection","Position":{"StartLine":16,"StartLinePosition":10,"StopLine":16,"StopLinePosition":45}}],"Position":{"StartLine":11,"StartLinePosition":4,"StopLine":18,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"uri","TypeType":"app_config"},{"TypeValue":"username","TypeType":"app_config"},{"TypeValue":"password","TypeType":"app_config"},{"TypeValue":"config.DATABASE_URL","TypeType":"f'bolt://{username}:{password}@{uri.split(\"://\")[-1]}'"}],"Content":"def __init__(self, app_config: AppConfig):        uri = app_config.neo4j_uri        username = app_config.neo4j_username        password = app_config.neo4j_password        config.DATABASE_URL = f'bolt://{username}:{password}@{uri.split(\"://\")[-1]}'        db.set_connection(config.DATABASE_URL)            "},{"Name":"close","FunctionCalls":[{"NodeName":"db","FunctionName":"close_connection","Position":{"StartLine":19,"StartLinePosition":10,"StopLine":19,"StopLinePosition":28}}],"Position":{"StartLine":18,"StartLinePosition":4,"StopLine":21,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"uri","TypeType":"app_config"},{"TypeValue":"username","TypeType":"app_config"},{"TypeValue":"password","TypeType":"app_config"},{"TypeValue":"config.DATABASE_URL","TypeType":"f'bolt://{username}:{password}@{uri.split(\"://\")[-1]}'"}],"Content":"def close(self):        db.close_connection()        "},{"Name":"create_schema","FunctionCalls":[{"NodeName":"db","FunctionName":"install_all_labels","Position":{"StartLine":22,"StartLinePosition":10,"StopLine":22,"StopLinePosition":30}}],"Position":{"StartLine":21,"StartLinePosition":4,"StopLine":24,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"uri","TypeType":"app_config"},{"TypeValue":"username","TypeType":"app_config"},{"TypeValue":"password","TypeType":"app_config"},{"TypeValue":"config.DATABASE_URL","TypeType":"f'bolt://{username}:{password}@{uri.split(\"://\")[-1]}'"}],"Content":"def create_schema(self):        db.install_all_labels()    "},{"Name":"create_vector_index","Parameters":[{"TypeValue":"label","TypeType":"str"},{"TypeValue":"property","TypeType":"str"},{"DefaultValue":"None","TypeValue":"dimension","TypeType":"int"},{"DefaultValue":"'cosine'","TypeValue":"similarity_function","TypeType":"str"}],"FunctionCalls":[{"FunctionName":"print","Position":{"StartLine":33,"StartLinePosition":21,"StopLine":33,"StopLinePosition":95}}],"Position":{"StartLine":24,"StartLinePosition":4,"StopLine":37,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"uri","TypeType":"app_config"},{"TypeValue":"username","TypeType":"app_config"},{"TypeValue":"password","TypeType":"app_config"},{"TypeValue":"config.DATABASE_URL","TypeType":"f'bolt://{username}:{password}@{uri.split(\"://\")[-1]}'"},{"TypeValue":"query","TypeType":""}],"Content":"def create_vector_index(self, label: str, property: str, dimension: int = None, similarity_function: str = 'cosine') -> None:        query = f\"CREATE VECTOR INDEX {property}_vector_index FOR (n:{label}) ON (n.{property})\"        if dimension is not None:            query += f\" OPTIONS {{indexConfig: {{`vector.dimensions`: {dimension}, `vector.similarity_function`: '{similarity_function}'}}}}\"        try:            # Using neomodel's db object to execute the query            db.cypher_query(query)        except Exception as e:            if \"equivalent index already exists\" in str(e):                print(f\"Vector index for {label}.{property} already exists. Skipping creation.\")            else:                raise  # Re-raise the exception if it's not about existing index    "},{"Name":"create_text_index","Parameters":[{"TypeValue":"label","TypeType":"str"},{"TypeValue":"property","TypeType":"str"}],"FunctionCalls":[{"NodeName":"db","FunctionName":"cypher_query","Position":{"StartLine":41,"StartLinePosition":10,"StopLine":41,"StopLinePosition":29}}],"Position":{"StartLine":37,"StartLinePosition":4,"StopLine":42},"LocalVariables":[{"TypeValue":"uri","TypeType":"app_config"},{"TypeValue":"username","TypeType":"app_config"},{"TypeValue":"password","TypeType":"app_config"},{"TypeValue":"config.DATABASE_URL","TypeType":"f'bolt://{username}:{password}@{uri.split(\"://\")[-1]}'"},{"TypeValue":"query","TypeType":"f\"CREATE TEXT INDEX {index_name} FOR (n:{label}) ON (n.{property})\""},{"TypeValue":"index_name","TypeType":"f\"{property.lower()}_text_index\""}],"Content":"def create_text_index(self, label: str, property: str) -> None:        index_name = f\"{property.lower()}_text_index\"        query = f\"CREATE TEXT INDEX {index_name} FOR (n:{label}) ON (n.{property})\"        # Using neomodel's db object to execute the query        db.cypher_query(query)"}],"Imports":[{"Source":"neomodel","UsageName":["config","db"]},{"Source":"unoplat_code_confluence.configuration.external_config","UsageName":["AppConfig"]}],"Position":{"StartLine":10,"StopLine":42},"Content":"class UnoplatGraphIngestion:    def __init__(self, app_config: AppConfig):        uri = app_config.neo4j_uri        username = app_config.neo4j_username        password = app_config.neo4j_password        config.DATABASE_URL = f'bolt://{username}:{password}@{uri.split(\"://\")[-1]}'        db.set_connection(config.DATABASE_URL)            def close(self):        db.close_connection()        def create_schema(self):        db.install_all_labels()    def create_vector_index(self, label: str, property: str, dimension: int = None, similarity_function: str = 'cosine') -> None:        query = f\"CREATE VECTOR INDEX {property}_vector_index FOR (n:{label}) ON (n.{property})\"        if dimension is not None:            query += f\" OPTIONS {{indexConfig: {{`vector.dimensions`: {dimension}, `vector.similarity_function`: '{similarity_function}'}}}}\"        try:            # Using neomodel's db object to execute the query            db.cypher_query(query)        except Exception as e:            if \"equivalent index already exists\" in str(e):                print(f\"Vector index for {label}.{property} already exists. Skipping creation.\")            else:                raise  # Re-raise the exception if it's not about existing index    def create_text_index(self, label: str, property: str) -> None:        index_name = f\"{property.lower()}_text_index\"        query = f\"CREATE TEXT INDEX {index_name} FOR (n:{label}) ON (n.{property})\"        # Using neomodel's db object to execute the query        db.cypher_query(query)"},{"NodeName":"Neo4jConnector","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/database/graph/__init__.py","Functions":[{"Name":"__init__","Parameters":[{"TypeValue":"uri","TypeType":"str"},{"TypeValue":"username","TypeType":"str"},{"TypeValue":"password","TypeType":"str"}],"FunctionCalls":[{"NodeName":"GraphDatabase","FunctionName":"driver","Position":{"StartLine":10,"StartLinePosition":35,"StopLine":10,"StopLinePosition":73}}],"Position":{"StartLine":9,"StartLinePosition":4,"StopLine":12,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"self.driver","TypeType":"GraphDatabase"}],"Content":"def __init__(self, uri: str, username: str, password: str):        self.driver = GraphDatabase.driver(uri, auth=(username, password))    "},{"Name":"close","FunctionCalls":[{"NodeName":"self","FunctionName":"driver","Position":{"StartLine":13,"StartLinePosition":12,"StopLine":13,"StopLinePosition":13}},{"NodeName":"self","FunctionName":"close","Position":{"StartLine":13,"StartLinePosition":19,"StopLine":13,"StopLinePosition":26}}],"Position":{"StartLine":12,"StartLinePosition":4,"StopLine":15,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"self.driver","TypeType":"GraphDatabase"}],"Content":"def close(self):        self.driver.close()    "},{"Name":"create_node","Parameters":[{"TypeValue":"label","TypeType":"str"},{"TypeValue":"properties","TypeType":"Dict[str,Any]"}],"FunctionCalls":[{"NodeName":"session","FunctionName":"run","Position":{"StartLine":17,"StartLinePosition":19,"StopLine":17,"StopLinePosition":69}}],"Position":{"StartLine":15,"StartLinePosition":4,"StopLine":19,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"self.driver","TypeType":"GraphDatabase"}],"Content":"def create_node(self, label: str, properties: Dict[str, Any]) -> None:        with self.driver.session() as session:            session.run(f\"MERGE (n:{label} $props)\", props=properties)    "},{"Name":"create_relationship","Parameters":[{"TypeValue":"start_node_label","TypeType":"str"},{"TypeValue":"start_node_property","TypeType":"str"},{"TypeValue":"end_node_label","TypeType":"str"},{"TypeValue":"end_node_property","TypeType":"str"},{"TypeValue":"relationship_type","TypeType":"str"}],"FunctionCalls":[{"NodeName":"session","FunctionName":"run","Position":{"StartLine":28,"StartLinePosition":19,"StopLine":28,"StopLinePosition":91}}],"Position":{"StartLine":19,"StartLinePosition":4,"StopLine":29},"LocalVariables":[{"TypeValue":"self.driver","TypeType":"GraphDatabase"},{"TypeValue":"query","TypeType":"f\"\"\"\n        MATCH (a:{start_node_label}), (b:{end_node_label})\n        WHERE a.{start_node_property} = $start_value AND b.{end_node_property} = $end_value\n        CREATE (a)-[:{relationship_type}]->(b)\n        \"\"\""}],"Content":"def create_relationship(self, start_node_label: str, start_node_property: str,                             end_node_label: str, end_node_property: str,                             relationship_type: str) -> None:        query = f\"\"\"        MATCH (a:{start_node_label}), (b:{end_node_label})        WHERE a.{start_node_property} = $start_value AND b.{end_node_property} = $end_value        CREATE (a)-[:{relationship_type}]->(b)        \"\"\"        with self.driver.session() as session:            session.run(query, start_value=start_node_property, end_value=end_node_property)"}],"Imports":[{"Source":"typing","UsageName":["Any","Dict"]},{"Source":"neo4j","UsageName":["GraphDatabase"]}],"Position":{"StartLine":8,"StopLine":29},"Content":"class Neo4jConnector:    def __init__(self, uri: str, username: str, password: str):        self.driver = GraphDatabase.driver(uri, auth=(username, password))    def close(self):        self.driver.close()    def create_node(self, label: str, properties: Dict[str, Any]) -> None:        with self.driver.session() as session:            session.run(f\"MERGE (n:{label} $props)\", props=properties)    def create_relationship(self, start_node_label: str, start_node_property: str,                             end_node_label: str, end_node_property: str,                             relationship_type: str) -> None:        query = f\"\"\"        MATCH (a:{start_node_label}), (b:{end_node_label})        WHERE a.{start_node_property} = $start_value AND b.{end_node_property} = $end_value        CREATE (a)-[:{relationship_type}]->(b)        \"\"\"        with self.driver.session() as session:            session.run(query, start_value=start_node_property, end_value=end_node_property)"},{"NodeName":"UnoplatGraphProcessing","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/database/graph/unoplat_graph_processing.py","Functions":[{"Name":"__init__","Parameters":[{"TypeValue":"app_config","TypeType":"AppConfig"}],"FunctionCalls":[{"NodeName":"self","FunctionName":"unoplat_graph_ingestion","Position":{"StartLine":30,"StartLinePosition":12,"StopLine":30,"StopLinePosition":13}},{"NodeName":"self","FunctionName":"create_schema","Position":{"StartLine":30,"StartLinePosition":36,"StopLine":30,"StopLinePosition":51}}],"Position":{"StartLine":23,"StartLinePosition":4,"StopLine":32,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"self.unoplat_graph_ingestion","TypeType":"UnoplatGraphIngestion"},{"TypeValue":"self.embedding_generator","TypeType":"UnoplatEmbeddingGenerator"},{"TypeValue":"neo4j_url","TypeType":"f'bolt://{app_config.neo4j_username}:{app_config.neo4j_password}@{app_config.neo4j_uri.split(\"://\")[-1]}'"},{"TypeValue":"config.DATABASE_URL","TypeType":"neo4j_url"}],"Content":"def __init__(self, app_config: AppConfig):        self.unoplat_graph_ingestion = UnoplatGraphIngestion(app_config)        self.embedding_generator = UnoplatEmbeddingGenerator(app_config)        # Configure neomodel connection        neo4j_url = f'bolt://{app_config.neo4j_username}:{app_config.neo4j_password}@{app_config.neo4j_uri.split(\"://\")[-1]}'        config.DATABASE_URL = neo4j_url        db.set_connection(neo4j_url)        self.unoplat_graph_ingestion.create_schema()    "},{"Name":"process_codebase_summary","Parameters":[{"TypeValue":"unoplat_codebase","TypeType":"UnoplatCodebase"},{"TypeValue":"codebase_summary","TypeType":"DspyUnoplatCodebaseSummary"}],"FunctionCalls":[{"NodeName":"db","FunctionName":"close_connection","Position":{"StartLine":74,"StartLinePosition":14,"StopLine":74,"StopLinePosition":32}}],"Position":{"StartLine":32,"StartLinePosition":4,"StopLine":76,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"self.unoplat_graph_ingestion","TypeType":"UnoplatGraphIngestion"},{"TypeValue":"self.embedding_generator","TypeType":"UnoplatEmbeddingGenerator"},{"TypeValue":"neo4j_url","TypeType":"f'bolt://{app_config.neo4j_username}:{app_config.neo4j_password}@{app_config.neo4j_uri.split(\"://\")[-1]}'"},{"TypeValue":"config.DATABASE_URL","TypeType":"neo4j_url"},{"TypeValue":"objective_embedding","TypeType":"self"},{"TypeValue":"implementation_embedding","TypeType":"self"},{"TypeValue":"codebase_node_dict","TypeType":"[{\"qualified_name\":codebase_summary.codebase_name,\"objective\":codebase_summary.codebase_objective,\"codebase_objective_embedding\":objective_embedding,\"implementation_summary\":codebase_summary.codebase_summary,\"codebase_implementation_summary_embedding\":implementation_embedding}]"},{"TypeValue":"codebase_node","TypeType":""},{"TypeValue":"stack","TypeType":"[(codebase_node,package_name,package_summary)forpackage_name,package_summaryincodebase_summary.codebase_package.items()]"},{"TypeValue":"","TypeType":"stack"},{"TypeValue":"processed_package","TypeType":"self"}],"Content":"def process_codebase_summary(self, unoplat_codebase: UnoplatCodebase, codebase_summary: DspyUnoplatCodebaseSummary):        try:            # Generate embeddings            objective_embedding = self.embedding_generator.generate_embeddings_for_single_text(                codebase_summary.codebase_objective)            implementation_embedding = self.embedding_generator.generate_embeddings_for_single_text(                codebase_summary.codebase_summary)                        # Create or update codebase node                        codebase_node_dict =  [             {                    \"qualified_name\": codebase_summary.codebase_name,                    \"objective\": codebase_summary.codebase_objective,                    \"codebase_objective_embedding\": objective_embedding,                    \"implementation_summary\": codebase_summary.codebase_summary,                    \"codebase_implementation_summary_embedding\": implementation_embedding            }            ]                        ConfluenceCodebase.create_or_update(*codebase_node_dict)            #TODO: handle none scenarios            codebase_node: ConfluenceCodebase = ConfluenceCodebase.nodes.get_or_none(qualified_name=codebase_summary.codebase_name)            # Process packages using DFS            stack = [(codebase_node, package_name, package_summary)                     for package_name, package_summary in codebase_summary.codebase_package.items()]            while stack:                parent_node, package_name, package_summary = stack.pop()                processed_package = self._process_package(parent_node, package_name, package_summary)                                # Add subpackages to stack                for subpackage_name, subpackage_summary in package_summary.sub_package_summaries.items():                    stack.append((processed_package, subpackage_name, subpackage_summary))                        self._create_vector_index_on_all_nodes(self.embedding_generator.get_dimensions())        except Exception as e:            logging.error(f\"Error processing codebase: {str(e)}\")            raise        finally:            db.close_connection()    "},{"Name":"_process_package","Parameters":[{"TypeValue":"parent_node","TypeType":""},{"TypeValue":"package_name","TypeType":"str"},{"TypeValue":"package_summary","TypeType":"DspyUnoplatPackageSummary"}],"FunctionCalls":[{"NodeName":"logging","FunctionName":"error","Position":{"StartLine":123,"StartLinePosition":19,"StopLine":123,"StopLinePosition":78}}],"Position":{"StartLine":76,"StartLinePosition":4,"StopLine":126,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"self.unoplat_graph_ingestion","TypeType":"UnoplatGraphIngestion"},{"TypeValue":"self.embedding_generator","TypeType":"UnoplatEmbeddingGenerator"},{"TypeValue":"neo4j_url","TypeType":"f'bolt://{app_config.neo4j_username}:{app_config.neo4j_password}@{app_config.neo4j_uri.split(\"://\")[-1]}'"},{"TypeValue":"config.DATABASE_URL","TypeType":"neo4j_url"},{"TypeValue":"objective_embedding","TypeType":"self"},{"TypeValue":"implementation_embedding","TypeType":"self"},{"TypeValue":"codebase_node_dict","TypeType":"[{\"qualified_name\":codebase_summary.codebase_name,\"objective\":codebase_summary.codebase_objective,\"codebase_objective_embedding\":objective_embedding,\"implementation_summary\":codebase_summary.codebase_summary,\"codebase_implementation_summary_embedding\":implementation_embedding}]"},{"TypeValue":"codebase_node","TypeType":""},{"TypeValue":"stack","TypeType":"[(codebase_node,package_name,package_summary)forpackage_name,package_summaryincodebase_summary.codebase_package.items()]"},{"TypeValue":"","TypeType":"stack"},{"TypeValue":"processed_package","TypeType":"self"},{"TypeValue":"package_objective_embedding","TypeType":"self"},{"TypeValue":"package_implementation_embedding","TypeType":"self"},{"TypeValue":"package_node_dict","TypeType":"[{\"qualified_name\":f\"{parent_node.qualified_name}.{package_name}\",\"objective\":package_summary.package_objective,\"package_objective_embedding\":package_objective_embedding,\"implementation_summary\":package_summary.package_summary,\"package_implementation_summary_embedding\":package_implementation_embedding}]"},{"TypeValue":"package_node","TypeType":""},{"TypeValue":"parent_node_relation_result","TypeType":"parent_node"},{"TypeValue":"package_node_relation_result","TypeType":"package_node"},{"TypeValue":"package_sub_package_relation_result","TypeType":"parent_node"},{"TypeValue":"sub_package_package_relation_result","TypeType":"package_node"}],"Content":"def _process_package(self, parent_node, package_name: str, package_summary: DspyUnoplatPackageSummary):        try:            # Generate embeddings            package_objective_embedding = self.embedding_generator.generate_embeddings_for_single_text(                package_summary.package_objective)            package_implementation_embedding = self.embedding_generator.generate_embeddings_for_single_text(                package_summary.package_summary)                        # Create package node            package_node_dict = [{                \"qualified_name\": f\"{parent_node.qualified_name}.{package_name}\",                \"objective\": package_summary.package_objective,                \"package_objective_embedding\": package_objective_embedding,                \"implementation_summary\": package_summary.package_summary,                \"package_implementation_summary_embedding\": package_implementation_embedding            }]                        ConfluencePackage.create_or_update(*package_node_dict)            package_node: ConfluencePackage = ConfluencePackage.nodes.get_or_none(qualified_name=f\"{parent_node.qualified_name}.{package_name}\")               # Connect to parent            if isinstance(parent_node, ConfluenceCodebase):                                if not parent_node.packages.is_connected(package_node):                    parent_node_relation_result = parent_node.packages.connect(package_node)                    logging.debug(f\"parent_node_relation_result: {parent_node_relation_result}\")                                if not package_node.confluence_codebase.is_connected(parent_node):                    package_node_relation_result = package_node.confluence_codebase.connect(parent_node)                    logging.debug(f\"package_node_relation_result: {package_node_relation_result}\")                                elif isinstance(parent_node, ConfluencePackage):                                if not parent_node.sub_packages.is_connected(package_node):                    package_sub_package_relation_result = parent_node.sub_packages.connect(package_node)                    logging.debug(f\"package_sub_package_relation_result: {package_sub_package_relation_result}\")                                if not package_node.sub_packages.is_connected(parent_node):                    sub_package_package_relation_result = package_node.sub_packages.connect(parent_node)                    logging.debug(f\"sub_package_package_relation_result: {sub_package_package_relation_result}\")            # Process classes            for class_summary in package_summary.class_summary:                self._process_class(package_node, class_summary)            return package_node        except Exception as e:            logging.error(f\"Error processing package {package_name}: {str(e)}\")            raise    "},{"Name":"_process_class","Parameters":[{"TypeValue":"package_node","TypeType":"ConfluencePackage"},{"TypeValue":"class_summary","TypeType":"DspyUnoplatNodeSummary"}],"FunctionCalls":[{"NodeName":"logging","FunctionName":"error","Position":{"StartLine":161,"StartLinePosition":19,"StopLine":161,"StopLinePosition":87}}],"Position":{"StartLine":126,"StartLinePosition":4,"StopLine":164,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"self.unoplat_graph_ingestion","TypeType":"UnoplatGraphIngestion"},{"TypeValue":"self.embedding_generator","TypeType":"UnoplatEmbeddingGenerator"},{"TypeValue":"neo4j_url","TypeType":"f'bolt://{app_config.neo4j_username}:{app_config.neo4j_password}@{app_config.neo4j_uri.split(\"://\")[-1]}'"},{"TypeValue":"config.DATABASE_URL","TypeType":"neo4j_url"},{"TypeValue":"objective_embedding","TypeType":"self"},{"TypeValue":"implementation_embedding","TypeType":"self"},{"TypeValue":"codebase_node_dict","TypeType":"[{\"qualified_name\":codebase_summary.codebase_name,\"objective\":codebase_summary.codebase_objective,\"codebase_objective_embedding\":objective_embedding,\"implementation_summary\":codebase_summary.codebase_summary,\"codebase_implementation_summary_embedding\":implementation_embedding}]"},{"TypeValue":"codebase_node","TypeType":""},{"TypeValue":"stack","TypeType":"[(codebase_node,package_name,package_summary)forpackage_name,package_summaryincodebase_summary.codebase_package.items()]"},{"TypeValue":"","TypeType":"stack"},{"TypeValue":"processed_package","TypeType":"self"},{"TypeValue":"package_objective_embedding","TypeType":"self"},{"TypeValue":"package_implementation_embedding","TypeType":"self"},{"TypeValue":"package_node_dict","TypeType":"[{\"qualified_name\":f\"{parent_node.qualified_name}.{package_name}\",\"objective\":package_summary.package_objective,\"package_objective_embedding\":package_objective_embedding,\"implementation_summary\":package_summary.package_summary,\"package_implementation_summary_embedding\":package_implementation_embedding}]"},{"TypeValue":"package_node","TypeType":""},{"TypeValue":"parent_node_relation_result","TypeType":"parent_node"},{"TypeValue":"package_node_relation_result","TypeType":"package_node"},{"TypeValue":"package_sub_package_relation_result","TypeType":"parent_node"},{"TypeValue":"sub_package_package_relation_result","TypeType":"package_node"},{"TypeValue":"class_objective_embedding","TypeType":"self"},{"TypeValue":"class_implementation_embedding","TypeType":"self"},{"TypeValue":"class_node_dict","TypeType":"[{\"qualified_name\":f\"{package_node.qualified_name}.{class_summary.node_name}\",\"class_name\":class_summary.node_name,\"objective\":class_summary.node_objective,\"class_objective_embedding\":class_objective_embedding,\"implementation_summary\":class_summary.node_summary,\"class_implementation_summary_embedding\":class_implementation_embedding}]"},{"TypeValue":"class_node","TypeType":""},{"TypeValue":"package_node_class_relation_result","TypeType":"package_node"},{"TypeValue":"class_node_package_relation_result","TypeType":"class_node"}],"Content":"def _process_class(self, package_node: ConfluencePackage, class_summary: DspyUnoplatNodeSummary):        try:            # Generate embeddings            class_objective_embedding = self.embedding_generator.generate_embeddings_for_single_text(                class_summary.node_objective)            class_implementation_embedding = self.embedding_generator.generate_embeddings_for_single_text(                class_summary.node_summary)                        # Create class node            class_node_dict = [{                \"qualified_name\": f\"{package_node.qualified_name}.{class_summary.node_name}\",                \"class_name\": class_summary.node_name,                \"objective\": class_summary.node_objective,                \"class_objective_embedding\": class_objective_embedding,                \"implementation_summary\": class_summary.node_summary,                \"class_implementation_summary_embedding\": class_implementation_embedding            }]                        ConfluenceClass.create_or_update(*class_node_dict)            class_node: ConfluenceClass = ConfluenceClass.nodes.get_or_none(qualified_name=f\"{package_node.qualified_name}.{class_summary.node_name}\")            # Connect to package            if not package_node.classes.is_connected(class_node):                package_node_class_relation_result = package_node.classes.connect(class_node)                logging.debug(f\"package_node_class_relation_result: {package_node_class_relation_result}\")                            if not class_node.package.is_connected(package_node):                class_node_package_relation_result = class_node.package.connect(package_node)                logging.debug(f\"class_node_package_relation_result: {class_node_package_relation_result}\")            # Process methods            for method_summary in class_summary.functions_summary:                self._process_method(class_node, method_summary)        except Exception as e:            logging.error(f\"Error processing class {class_summary.node_name}: {str(e)}\")            raise    "},{"Name":"_process_method","Parameters":[{"TypeValue":"class_node","TypeType":"ConfluenceClass"},{"TypeValue":"method_summary","TypeType":"DspyUnoplatFunctionSummary"}],"FunctionCalls":[{"NodeName":"logging","FunctionName":"error","Position":{"StartLine":195,"StartLinePosition":19,"StopLine":195,"StopLinePosition":93}}],"Position":{"StartLine":164,"StartLinePosition":4,"StopLine":198,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"self.unoplat_graph_ingestion","TypeType":"UnoplatGraphIngestion"},{"TypeValue":"self.embedding_generator","TypeType":"UnoplatEmbeddingGenerator"},{"TypeValue":"neo4j_url","TypeType":"f'bolt://{app_config.neo4j_username}:{app_config.neo4j_password}@{app_config.neo4j_uri.split(\"://\")[-1]}'"},{"TypeValue":"config.DATABASE_URL","TypeType":"neo4j_url"},{"TypeValue":"objective_embedding","TypeType":"self"},{"TypeValue":"implementation_embedding","TypeType":"self"},{"TypeValue":"codebase_node_dict","TypeType":"[{\"qualified_name\":codebase_summary.codebase_name,\"objective\":codebase_summary.codebase_objective,\"codebase_objective_embedding\":objective_embedding,\"implementation_summary\":codebase_summary.codebase_summary,\"codebase_implementation_summary_embedding\":implementation_embedding}]"},{"TypeValue":"codebase_node","TypeType":""},{"TypeValue":"stack","TypeType":"[(codebase_node,package_name,package_summary)forpackage_name,package_summaryincodebase_summary.codebase_package.items()]"},{"TypeValue":"","TypeType":"stack"},{"TypeValue":"processed_package","TypeType":"self"},{"TypeValue":"package_objective_embedding","TypeType":"self"},{"TypeValue":"package_implementation_embedding","TypeType":"self"},{"TypeValue":"package_node_dict","TypeType":"[{\"qualified_name\":f\"{parent_node.qualified_name}.{package_name}\",\"objective\":package_summary.package_objective,\"package_objective_embedding\":package_objective_embedding,\"implementation_summary\":package_summary.package_summary,\"package_implementation_summary_embedding\":package_implementation_embedding}]"},{"TypeValue":"package_node","TypeType":""},{"TypeValue":"parent_node_relation_result","TypeType":"parent_node"},{"TypeValue":"package_node_relation_result","TypeType":"package_node"},{"TypeValue":"package_sub_package_relation_result","TypeType":"parent_node"},{"TypeValue":"sub_package_package_relation_result","TypeType":"package_node"},{"TypeValue":"class_objective_embedding","TypeType":"self"},{"TypeValue":"class_implementation_embedding","TypeType":"self"},{"TypeValue":"class_node_dict","TypeType":"[{\"qualified_name\":f\"{package_node.qualified_name}.{class_summary.node_name}\",\"class_name\":class_summary.node_name,\"objective\":class_summary.node_objective,\"class_objective_embedding\":class_objective_embedding,\"implementation_summary\":class_summary.node_summary,\"class_implementation_summary_embedding\":class_implementation_embedding}]"},{"TypeValue":"class_node","TypeType":""},{"TypeValue":"package_node_class_relation_result","TypeType":"package_node"},{"TypeValue":"class_node_package_relation_result","TypeType":"class_node"},{"TypeValue":"method_objective_embedding","TypeType":"self"},{"TypeValue":"method_implementation_embedding","TypeType":"self"},{"TypeValue":"method_node_dict","TypeType":"[{\"qualified_name\":f\"{class_node.qualified_name}.{method_summary.function_name}\",\"function_name\":method_summary.function_name,\"objective\":method_summary.objective,\"function_objective_embedding\":method_objective_embedding,\"implementation_summary\":method_summary.implementation_summary,\"function_implementation_summary_embedding\":method_implementation_embedding}]"},{"TypeValue":"method_node","TypeType":""},{"TypeValue":"class_node_method_relation_result","TypeType":"class_node"},{"TypeValue":"method_node_class_relation_result","TypeType":"method_node"}],"Content":"def _process_method(self, class_node: ConfluenceClass, method_summary: DspyUnoplatFunctionSummary):        try:            # Generate embeddings            method_objective_embedding = self.embedding_generator.generate_embeddings_for_single_text(                method_summary.function_summary.objective)            method_implementation_embedding = self.embedding_generator.generate_embeddings_for_single_text(                method_summary.function_summary.implementation_summary)                        # Create method node            method_node_dict = [{                \"qualified_name\": f\"{class_node.qualified_name}.{method_summary.function_name}\",                \"function_name\": method_summary.function_name,                \"objective\": method_summary.objective,                \"function_objective_embedding\": method_objective_embedding,                \"implementation_summary\": method_summary.implementation_summary,                \"function_implementation_summary_embedding\": method_implementation_embedding            }]                        ConfluenceMethod.create_or_update(*method_node_dict)            method_node: ConfluenceMethod = ConfluenceMethod.nodes.get_or_none(qualified_name=f\"{class_node.qualified_name}.{method_summary.function_name}\")            # Connect to class            if not class_node.methods.is_connected(method_node):                class_node_method_relation_result = class_node.methods.connect(method_node)                logging.debug(f\"class_node_method_relation_result: {class_node_method_relation_result}\")                            if not method_node.confluence_class.is_connected(class_node):                method_node_class_relation_result = method_node.confluence_class.connect(class_node)                logging.debug(f\"method_node_class_relation_result: {method_node_class_relation_result}\")        except Exception as e:            logging.error(f\"Error processing method {method_summary.function_name}: {str(e)}\")            raise    "},{"Name":"_create_vector_index_on_all_nodes","Parameters":[{"TypeValue":"dimensions","TypeType":"int"}],"FunctionCalls":[{"NodeName":"self","FunctionName":"_create_vector_index","Position":{"StartLine":209,"StartLinePosition":24,"StopLine":209,"StopLinePosition":128}}],"Position":{"StartLine":198,"StartLinePosition":4,"StopLine":211,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"self.unoplat_graph_ingestion","TypeType":"UnoplatGraphIngestion"},{"TypeValue":"self.embedding_generator","TypeType":"UnoplatEmbeddingGenerator"},{"TypeValue":"neo4j_url","TypeType":"f'bolt://{app_config.neo4j_username}:{app_config.neo4j_password}@{app_config.neo4j_uri.split(\"://\")[-1]}'"},{"TypeValue":"config.DATABASE_URL","TypeType":"neo4j_url"},{"TypeValue":"objective_embedding","TypeType":"self"},{"TypeValue":"implementation_embedding","TypeType":"self"},{"TypeValue":"codebase_node_dict","TypeType":"[{\"qualified_name\":codebase_summary.codebase_name,\"objective\":codebase_summary.codebase_objective,\"codebase_objective_embedding\":objective_embedding,\"implementation_summary\":codebase_summary.codebase_summary,\"codebase_implementation_summary_embedding\":implementation_embedding}]"},{"TypeValue":"codebase_node","TypeType":""},{"TypeValue":"stack","TypeType":"[(codebase_node,package_name,package_summary)forpackage_name,package_summaryincodebase_summary.codebase_package.items()]"},{"TypeValue":"","TypeType":"stack"},{"TypeValue":"processed_package","TypeType":"self"},{"TypeValue":"package_objective_embedding","TypeType":"self"},{"TypeValue":"package_implementation_embedding","TypeType":"self"},{"TypeValue":"package_node_dict","TypeType":"[{\"qualified_name\":f\"{parent_node.qualified_name}.{package_name}\",\"objective\":package_summary.package_objective,\"package_objective_embedding\":package_objective_embedding,\"implementation_summary\":package_summary.package_summary,\"package_implementation_summary_embedding\":package_implementation_embedding}]"},{"TypeValue":"package_node","TypeType":""},{"TypeValue":"parent_node_relation_result","TypeType":"parent_node"},{"TypeValue":"package_node_relation_result","TypeType":"package_node"},{"TypeValue":"package_sub_package_relation_result","TypeType":"parent_node"},{"TypeValue":"sub_package_package_relation_result","TypeType":"package_node"},{"TypeValue":"class_objective_embedding","TypeType":"self"},{"TypeValue":"class_implementation_embedding","TypeType":"self"},{"TypeValue":"class_node_dict","TypeType":"[{\"qualified_name\":f\"{package_node.qualified_name}.{class_summary.node_name}\",\"class_name\":class_summary.node_name,\"objective\":class_summary.node_objective,\"class_objective_embedding\":class_objective_embedding,\"implementation_summary\":class_summary.node_summary,\"class_implementation_summary_embedding\":class_implementation_embedding}]"},{"TypeValue":"class_node","TypeType":""},{"TypeValue":"package_node_class_relation_result","TypeType":"package_node"},{"TypeValue":"class_node_package_relation_result","TypeType":"class_node"},{"TypeValue":"method_objective_embedding","TypeType":"self"},{"TypeValue":"method_implementation_embedding","TypeType":"self"},{"TypeValue":"method_node_dict","TypeType":"[{\"qualified_name\":f\"{class_node.qualified_name}.{method_summary.function_name}\",\"function_name\":method_summary.function_name,\"objective\":method_summary.objective,\"function_objective_embedding\":method_objective_embedding,\"implementation_summary\":method_summary.implementation_summary,\"function_implementation_summary_embedding\":method_implementation_embedding}]"},{"TypeValue":"method_node","TypeType":""},{"TypeValue":"class_node_method_relation_result","TypeType":"class_node"},{"TypeValue":"method_node_class_relation_result","TypeType":"method_node"},{"TypeValue":"node_embedding_properties","TypeType":"{\"ConfluenceCodebase\":[\"codebase_objective_embedding\",\"codebase_implementation_summary_embedding\"],\"ConfluencePackage\":[\"package_objective_embedding\",\"package_implementation_summary_embedding\"],\"ConfluenceClass\":[\"class_objective_embedding\",\"class_implementation_summary_embedding\"],\"ConfluenceMethod\":[\"function_objective_embedding\",\"function_implementation_summary_embedding\"]}"}],"Content":"def _create_vector_index_on_all_nodes(self, dimensions: int):            # Create vector indexes for all node types            node_embedding_properties = {                \"ConfluenceCodebase\": [\"codebase_objective_embedding\", \"codebase_implementation_summary_embedding\"],                \"ConfluencePackage\": [\"package_objective_embedding\", \"package_implementation_summary_embedding\"],                \"ConfluenceClass\": [\"class_objective_embedding\", \"class_implementation_summary_embedding\"],                \"ConfluenceMethod\": [\"function_objective_embedding\", \"function_implementation_summary_embedding\"]            }                        for node_type, embedding_properties in node_embedding_properties.items():                for embedding_property in embedding_properties:                    self._create_vector_index(node_label=node_type, embedding_property=embedding_property, dimensions=dimensions)    "},{"Name":"_create_vector_index","Parameters":[{"TypeValue":"node_label","TypeType":"str"},{"TypeValue":"embedding_property","TypeType":"str"},{"TypeValue":"dimensions","TypeType":"int"}],"FunctionCalls":[{"NodeName":"self","FunctionName":"unoplat_graph_ingestion","Position":{"StartLine":212,"StartLinePosition":12,"StopLine":212,"StopLinePosition":13}},{"NodeName":"self","FunctionName":"create_vector_index","Position":{"StartLine":212,"StartLinePosition":36,"StopLine":212,"StopLinePosition":123}}],"Position":{"StartLine":211,"StartLinePosition":4,"StopLine":213},"LocalVariables":[{"TypeValue":"self.unoplat_graph_ingestion","TypeType":"UnoplatGraphIngestion"},{"TypeValue":"self.embedding_generator","TypeType":"UnoplatEmbeddingGenerator"},{"TypeValue":"neo4j_url","TypeType":"f'bolt://{app_config.neo4j_username}:{app_config.neo4j_password}@{app_config.neo4j_uri.split(\"://\")[-1]}'"},{"TypeValue":"config.DATABASE_URL","TypeType":"neo4j_url"},{"TypeValue":"objective_embedding","TypeType":"self"},{"TypeValue":"implementation_embedding","TypeType":"self"},{"TypeValue":"codebase_node_dict","TypeType":"[{\"qualified_name\":codebase_summary.codebase_name,\"objective\":codebase_summary.codebase_objective,\"codebase_objective_embedding\":objective_embedding,\"implementation_summary\":codebase_summary.codebase_summary,\"codebase_implementation_summary_embedding\":implementation_embedding}]"},{"TypeValue":"codebase_node","TypeType":""},{"TypeValue":"stack","TypeType":"[(codebase_node,package_name,package_summary)forpackage_name,package_summaryincodebase_summary.codebase_package.items()]"},{"TypeValue":"","TypeType":"stack"},{"TypeValue":"processed_package","TypeType":"self"},{"TypeValue":"package_objective_embedding","TypeType":"self"},{"TypeValue":"package_implementation_embedding","TypeType":"self"},{"TypeValue":"package_node_dict","TypeType":"[{\"qualified_name\":f\"{parent_node.qualified_name}.{package_name}\",\"objective\":package_summary.package_objective,\"package_objective_embedding\":package_objective_embedding,\"implementation_summary\":package_summary.package_summary,\"package_implementation_summary_embedding\":package_implementation_embedding}]"},{"TypeValue":"package_node","TypeType":""},{"TypeValue":"parent_node_relation_result","TypeType":"parent_node"},{"TypeValue":"package_node_relation_result","TypeType":"package_node"},{"TypeValue":"package_sub_package_relation_result","TypeType":"parent_node"},{"TypeValue":"sub_package_package_relation_result","TypeType":"package_node"},{"TypeValue":"class_objective_embedding","TypeType":"self"},{"TypeValue":"class_implementation_embedding","TypeType":"self"},{"TypeValue":"class_node_dict","TypeType":"[{\"qualified_name\":f\"{package_node.qualified_name}.{class_summary.node_name}\",\"class_name\":class_summary.node_name,\"objective\":class_summary.node_objective,\"class_objective_embedding\":class_objective_embedding,\"implementation_summary\":class_summary.node_summary,\"class_implementation_summary_embedding\":class_implementation_embedding}]"},{"TypeValue":"class_node","TypeType":""},{"TypeValue":"package_node_class_relation_result","TypeType":"package_node"},{"TypeValue":"class_node_package_relation_result","TypeType":"class_node"},{"TypeValue":"method_objective_embedding","TypeType":"self"},{"TypeValue":"method_implementation_embedding","TypeType":"self"},{"TypeValue":"method_node_dict","TypeType":"[{\"qualified_name\":f\"{class_node.qualified_name}.{method_summary.function_name}\",\"function_name\":method_summary.function_name,\"objective\":method_summary.objective,\"function_objective_embedding\":method_objective_embedding,\"implementation_summary\":method_summary.implementation_summary,\"function_implementation_summary_embedding\":method_implementation_embedding}]"},{"TypeValue":"method_node","TypeType":""},{"TypeValue":"class_node_method_relation_result","TypeType":"class_node"},{"TypeValue":"method_node_class_relation_result","TypeType":"method_node"},{"TypeValue":"node_embedding_properties","TypeType":"{\"ConfluenceCodebase\":[\"codebase_objective_embedding\",\"codebase_implementation_summary_embedding\"],\"ConfluencePackage\":[\"package_objective_embedding\",\"package_implementation_summary_embedding\"],\"ConfluenceClass\":[\"class_objective_embedding\",\"class_implementation_summary_embedding\"],\"ConfluenceMethod\":[\"function_objective_embedding\",\"function_implementation_summary_embedding\"]}"}],"Content":"def _create_vector_index(self, node_label: str, embedding_property: str, dimensions: int):        self.unoplat_graph_ingestion.create_vector_index(label=node_label, dimension=dimensions,property=embedding_property)"}],"Imports":[{"Source":"logging"},{"Source":"neomodel","UsageName":["config","db"]},{"Source":"unoplat_code_confluence_commons.graph_models.confluence_class","UsageName":["ConfluenceClass"]},{"Source":"unoplat_code_confluence_commons.graph_models.confluence_codebase","UsageName":["ConfluenceCodebase"]},{"Source":"unoplat_code_confluence_commons.graph_models.confluence_method","UsageName":["ConfluenceMethod"]},{"Source":"unoplat_code_confluence_commons.graph_models.confluence_package","UsageName":["ConfluencePackage"]},{"Source":"unoplat_code_confluence.configuration.external_config","UsageName":["AppConfig"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_codebase","UsageName":["UnoplatCodebase"]},{"Source":"unoplat_code_confluence.data_models.dspy.dspy_unoplat_codebase_summary","UsageName":["DspyUnoplatCodebaseSummary"]},{"Source":"unoplat_code_confluence.data_models.dspy.dspy_unoplat_function_summary","UsageName":["DspyUnoplatFunctionSummary"]},{"Source":"unoplat_code_confluence.data_models.dspy.dspy_unoplat_node_summary","UsageName":["DspyUnoplatNodeSummary"]},{"Source":"unoplat_code_confluence.data_models.dspy.dspy_unoplat_package_summary","UsageName":["DspyUnoplatPackageSummary"]},{"Source":"unoplat_code_confluence.database.graph.unoplat_graph_ingestion","UsageName":["UnoplatGraphIngestion"]},{"Source":"unoplat_code_confluence.embedding.unoplat_embedding_gen","UsageName":["UnoplatEmbeddingGenerator"]}],"Position":{"StartLine":22,"StopLine":213},"Content":"class UnoplatGraphProcessing:    def __init__(self, app_config: AppConfig):        self.unoplat_graph_ingestion = UnoplatGraphIngestion(app_config)        self.embedding_generator = UnoplatEmbeddingGenerator(app_config)        # Configure neomodel connection        neo4j_url = f'bolt://{app_config.neo4j_username}:{app_config.neo4j_password}@{app_config.neo4j_uri.split(\"://\")[-1]}'        config.DATABASE_URL = neo4j_url        db.set_connection(neo4j_url)        self.unoplat_graph_ingestion.create_schema()    def process_codebase_summary(self, unoplat_codebase: UnoplatCodebase, codebase_summary: DspyUnoplatCodebaseSummary):        try:            # Generate embeddings            objective_embedding = self.embedding_generator.generate_embeddings_for_single_text(                codebase_summary.codebase_objective)            implementation_embedding = self.embedding_generator.generate_embeddings_for_single_text(                codebase_summary.codebase_summary)                        # Create or update codebase node                        codebase_node_dict =  [             {                    \"qualified_name\": codebase_summary.codebase_name,                    \"objective\": codebase_summary.codebase_objective,                    \"codebase_objective_embedding\": objective_embedding,                    \"implementation_summary\": codebase_summary.codebase_summary,                    \"codebase_implementation_summary_embedding\": implementation_embedding            }            ]                        ConfluenceCodebase.create_or_update(*codebase_node_dict)            #TODO: handle none scenarios            codebase_node: ConfluenceCodebase = ConfluenceCodebase.nodes.get_or_none(qualified_name=codebase_summary.codebase_name)            # Process packages using DFS            stack = [(codebase_node, package_name, package_summary)                     for package_name, package_summary in codebase_summary.codebase_package.items()]            while stack:                parent_node, package_name, package_summary = stack.pop()                processed_package = self._process_package(parent_node, package_name, package_summary)                                # Add subpackages to stack                for subpackage_name, subpackage_summary in package_summary.sub_package_summaries.items():                    stack.append((processed_package, subpackage_name, subpackage_summary))                        self._create_vector_index_on_all_nodes(self.embedding_generator.get_dimensions())        except Exception as e:            logging.error(f\"Error processing codebase: {str(e)}\")            raise        finally:            db.close_connection()    def _process_package(self, parent_node, package_name: str, package_summary: DspyUnoplatPackageSummary):        try:            # Generate embeddings            package_objective_embedding = self.embedding_generator.generate_embeddings_for_single_text(                package_summary.package_objective)            package_implementation_embedding = self.embedding_generator.generate_embeddings_for_single_text(                package_summary.package_summary)                        # Create package node            package_node_dict = [{                \"qualified_name\": f\"{parent_node.qualified_name}.{package_name}\",                \"objective\": package_summary.package_objective,                \"package_objective_embedding\": package_objective_embedding,                \"implementation_summary\": package_summary.package_summary,                \"package_implementation_summary_embedding\": package_implementation_embedding            }]                        ConfluencePackage.create_or_update(*package_node_dict)            package_node: ConfluencePackage = ConfluencePackage.nodes.get_or_none(qualified_name=f\"{parent_node.qualified_name}.{package_name}\")               # Connect to parent            if isinstance(parent_node, ConfluenceCodebase):                                if not parent_node.packages.is_connected(package_node):                    parent_node_relation_result = parent_node.packages.connect(package_node)                    logging.debug(f\"parent_node_relation_result: {parent_node_relation_result}\")                                if not package_node.confluence_codebase.is_connected(parent_node):                    package_node_relation_result = package_node.confluence_codebase.connect(parent_node)                    logging.debug(f\"package_node_relation_result: {package_node_relation_result}\")                                elif isinstance(parent_node, ConfluencePackage):                                if not parent_node.sub_packages.is_connected(package_node):                    package_sub_package_relation_result = parent_node.sub_packages.connect(package_node)                    logging.debug(f\"package_sub_package_relation_result: {package_sub_package_relation_result}\")                                if not package_node.sub_packages.is_connected(parent_node):                    sub_package_package_relation_result = package_node.sub_packages.connect(parent_node)                    logging.debug(f\"sub_package_package_relation_result: {sub_package_package_relation_result}\")            # Process classes            for class_summary in package_summary.class_summary:                self._process_class(package_node, class_summary)            return package_node        except Exception as e:            logging.error(f\"Error processing package {package_name}: {str(e)}\")            raise    def _process_class(self, package_node: ConfluencePackage, class_summary: DspyUnoplatNodeSummary):        try:            # Generate embeddings            class_objective_embedding = self.embedding_generator.generate_embeddings_for_single_text(                class_summary.node_objective)            class_implementation_embedding = self.embedding_generator.generate_embeddings_for_single_text(                class_summary.node_summary)                        # Create class node            class_node_dict = [{                \"qualified_name\": f\"{package_node.qualified_name}.{class_summary.node_name}\",                \"class_name\": class_summary.node_name,                \"objective\": class_summary.node_objective,                \"class_objective_embedding\": class_objective_embedding,                \"implementation_summary\": class_summary.node_summary,                \"class_implementation_summary_embedding\": class_implementation_embedding            }]                        ConfluenceClass.create_or_update(*class_node_dict)            class_node: ConfluenceClass = ConfluenceClass.nodes.get_or_none(qualified_name=f\"{package_node.qualified_name}.{class_summary.node_name}\")            # Connect to package            if not package_node.classes.is_connected(class_node):                package_node_class_relation_result = package_node.classes.connect(class_node)                logging.debug(f\"package_node_class_relation_result: {package_node_class_relation_result}\")                            if not class_node.package.is_connected(package_node):                class_node_package_relation_result = class_node.package.connect(package_node)                logging.debug(f\"class_node_package_relation_result: {class_node_package_relation_result}\")            # Process methods            for method_summary in class_summary.functions_summary:                self._process_method(class_node, method_summary)        except Exception as e:            logging.error(f\"Error processing class {class_summary.node_name}: {str(e)}\")            raise    def _process_method(self, class_node: ConfluenceClass, method_summary: DspyUnoplatFunctionSummary):        try:            # Generate embeddings            method_objective_embedding = self.embedding_generator.generate_embeddings_for_single_text(                method_summary.function_summary.objective)            method_implementation_embedding = self.embedding_generator.generate_embeddings_for_single_text(                method_summary.function_summary.implementation_summary)                        # Create method node            method_node_dict = [{                \"qualified_name\": f\"{class_node.qualified_name}.{method_summary.function_name}\",                \"function_name\": method_summary.function_name,                \"objective\": method_summary.objective,                \"function_objective_embedding\": method_objective_embedding,                \"implementation_summary\": method_summary.implementation_summary,                \"function_implementation_summary_embedding\": method_implementation_embedding            }]                        ConfluenceMethod.create_or_update(*method_node_dict)            method_node: ConfluenceMethod = ConfluenceMethod.nodes.get_or_none(qualified_name=f\"{class_node.qualified_name}.{method_summary.function_name}\")            # Connect to class            if not class_node.methods.is_connected(method_node):                class_node_method_relation_result = class_node.methods.connect(method_node)                logging.debug(f\"class_node_method_relation_result: {class_node_method_relation_result}\")                            if not method_node.confluence_class.is_connected(class_node):                method_node_class_relation_result = method_node.confluence_class.connect(class_node)                logging.debug(f\"method_node_class_relation_result: {method_node_class_relation_result}\")        except Exception as e:            logging.error(f\"Error processing method {method_summary.function_name}: {str(e)}\")            raise    def _create_vector_index_on_all_nodes(self, dimensions: int):            # Create vector indexes for all node types            node_embedding_properties = {                \"ConfluenceCodebase\": [\"codebase_objective_embedding\", \"codebase_implementation_summary_embedding\"],                \"ConfluencePackage\": [\"package_objective_embedding\", \"package_implementation_summary_embedding\"],                \"ConfluenceClass\": [\"class_objective_embedding\", \"class_implementation_summary_embedding\"],                \"ConfluenceMethod\": [\"function_objective_embedding\", \"function_implementation_summary_embedding\"]            }                        for node_type, embedding_properties in node_embedding_properties.items():                for embedding_property in embedding_properties:                    self._create_vector_index(node_label=node_type, embedding_property=embedding_property, dimensions=dimensions)    def _create_vector_index(self, node_label: str, embedding_property: str, dimensions: int):        self.unoplat_graph_ingestion.create_vector_index(label=node_label, dimension=dimensions,property=embedding_property)"},{"NodeName":"ProgrammingLanguage","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/configuration/external_config.py","MultipleExtend":["Enum"],"Imports":[{"Source":"enum","UsageName":["Enum"]},{"Source":"typing","UsageName":["Any","Dict","List"]},{"Source":"pydantic","UsageName":["BaseModel","Field","ValidationInfo","field_validator"]}],"Position":{"StartLine":9,"StopLine":20},"Content":"class ProgrammingLanguage(Enum):    PYTHON = 'python'    JAVA = 'java'    # JAVASCRIPT = 'JavaScript'    # CSHARP = 'C#'    # RUBY = 'Ruby'    # GO = 'Go'    # KOTLIN = 'Kotlin'    # SWIFT = 'Swift'"},{"NodeName":"RepoConfig","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/configuration/external_config.py","MultipleExtend":["BaseModel"],"Imports":[{"Source":"enum","UsageName":["Enum"]},{"Source":"typing","UsageName":["Any","Dict","List"]},{"Source":"pydantic","UsageName":["BaseModel","Field","ValidationInfo","field_validator"]}],"Position":{"StartLine":20,"StopLine":24},"Content":"class RepoConfig(BaseModel):    download_url: str    download_directory: str"},{"NodeName":"AppConfig","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/configuration/external_config.py","MultipleExtend":["BaseModel"],"Functions":[{"Name":"check_programming_language","Parameters":[{"TypeValue":"cls","TypeType":""},{"TypeValue":"value","TypeType":""},{"TypeValue":"info","TypeType":"ValidationInfo"}],"Annotations":[{"Name":"field_validator","KeyValues":[{"Key":"'programming_language'"}],"Position":{"StartLine":51,"StartLinePosition":4,"StopLine":52,"StopLinePosition":4}}],"Position":{"StartLine":52,"StartLinePosition":4,"StopLine":58,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"PYTHON","TypeType":"'python'"},{"TypeValue":"JAVA","TypeType":"'java'"},{"TypeValue":"download_url","TypeType":""},{"TypeValue":"download_directory","TypeType":""},{"TypeValue":"local_workspace_path","TypeType":""},{"TypeValue":"output_path","TypeType":""},{"TypeValue":"output_file_name","TypeType":""},{"TypeValue":"codebase_name","TypeType":""},{"TypeValue":"programming_language","TypeType":""},{"TypeValue":"repo","TypeType":""},{"TypeValue":"api_tokens","TypeType":""},{"TypeValue":"llm_provider_config","TypeType":""},{"TypeValue":"handlers","TypeType":""},{"TypeValue":"parallisation","TypeType":""},{"TypeValue":"json_output","TypeType":""},{"TypeValue":"sentence_transformer_model","TypeType":""},{"TypeValue":"neo4j_uri","TypeType":""},{"TypeValue":"neo4j_username","TypeType":""},{"TypeValue":"neo4j_password","TypeType":""}],"Content":"def check_programming_language(cls, value, info:ValidationInfo):        if value not in [member.value for member in ProgrammingLanguage]:            raise ValueError(\"programming_language must be a valid programming language\")        return value    "},{"Name":"check_api_tokens","Parameters":[{"TypeValue":"cls","TypeType":""},{"TypeValue":"value","TypeType":""},{"TypeValue":"info","TypeType":"ValidationInfo"}],"Annotations":[{"Name":"field_validator","KeyValues":[{"Key":"'api_tokens'"}],"Position":{"StartLine":58,"StartLinePosition":4,"StopLine":59,"StopLinePosition":4}}],"Position":{"StartLine":59,"StartLinePosition":4,"StopLine":65},"LocalVariables":[{"TypeValue":"PYTHON","TypeType":"'python'"},{"TypeValue":"JAVA","TypeType":"'java'"},{"TypeValue":"download_url","TypeType":""},{"TypeValue":"download_directory","TypeType":""},{"TypeValue":"local_workspace_path","TypeType":""},{"TypeValue":"output_path","TypeType":""},{"TypeValue":"output_file_name","TypeType":""},{"TypeValue":"codebase_name","TypeType":""},{"TypeValue":"programming_language","TypeType":""},{"TypeValue":"repo","TypeType":""},{"TypeValue":"api_tokens","TypeType":""},{"TypeValue":"llm_provider_config","TypeType":""},{"TypeValue":"handlers","TypeType":""},{"TypeValue":"parallisation","TypeType":""},{"TypeValue":"json_output","TypeType":""},{"TypeValue":"sentence_transformer_model","TypeType":""},{"TypeValue":"neo4j_uri","TypeType":""},{"TypeValue":"neo4j_username","TypeType":""},{"TypeValue":"neo4j_password","TypeType":""}],"Content":"def check_api_tokens(cls, value, info:ValidationInfo):        if 'github_token' not in value:            raise ValueError(\"github_token is required in api_tokens\")        if len(value) != 1:            raise ValueError(\"api_tokens must only contain github_token\")        return value"}],"Imports":[{"Source":"enum","UsageName":["Enum"]},{"Source":"typing","UsageName":["Any","Dict","List"]},{"Source":"pydantic","UsageName":["BaseModel","Field","ValidationInfo","field_validator"]}],"Position":{"StartLine":24,"StopLine":65},"Content":"class AppConfig(BaseModel):    local_workspace_path: str    output_path: str    output_file_name: str    codebase_name: str    programming_language: str    repo: RepoConfig    api_tokens: Dict[str, str]    llm_provider_config: Dict[str, Any] = Field(        description=\"Configuration for the LLM provider based on litellm\",        example={            \"model_provider\": \"openai/gpt-4\",            \"model_provider_args\": {                \"api_key\": \"sk-...\",                \"max_tokens\": 500,                \"temperature\": 0.0            }        }    )    handlers: List[Dict[str, Any]] = Field(default_factory=list,alias=\"logging_handlers\")    parallisation: int = 1    json_output: bool = False    sentence_transformer_model: str = Field(default=\"jinaai/jina-embeddings-v3\", description=\"Name or path of the sentence transformer model\")    neo4j_uri: str = Field(default=\"bolt://localhost:7687\", description=\"URI of the Neo4j database\")    neo4j_username: str = Field(default=\"neo4j\", description=\"Username for the Neo4j database\")    neo4j_password: str = Field(default=\"Ke7Rk7jB:Jn2Uz:\", description=\"Password for the Neo4j database\")     @field_validator('programming_language')    def check_programming_language(cls, value, info:ValidationInfo):        if value not in [member.value for member in ProgrammingLanguage]:            raise ValueError(\"programming_language must be a valid programming language\")        return value    @field_validator('api_tokens')    def check_api_tokens(cls, value, info:ValidationInfo):        if 'github_token' not in value:            raise ValueError(\"github_token is required in api_tokens\")        if len(value) != 1:            raise ValueError(\"api_tokens must only contain github_token\")        return value"},{"NodeName":"CodeConfluenceFunctionSummary","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/dspy_function_summary.py","MultipleExtend":["dspy.Signature"],"Imports":[{"Source":"dspy"},{"Source":"loguru","UsageName":["logger"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_function","UsageName":["ChapiUnoplatFunction"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_node","UsageName":["ChapiUnoplatNode"]}],"Position":{"StartLine":11,"StopLine":17},"Content":"class CodeConfluenceFunctionSummary(dspy.Signature):    \"\"\"This signature takes in metadata about function in a class and returns unoplat_function_summary with all important details.\"\"\"    function_json_schema: str = dspy.InputField(desc=\"This will contain json schema of the function metadata\")    chapi_function_metadata: str = dspy.InputField(desc=\"This will contain relevant function metadata regarding the function\")    unoplat_function_summary: str = dspy.OutputField(desc=\"This will contain function summary based on function metadata.\")"},{"NodeName":"CodeConfluenceFunctionCallSummary","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/dspy_function_summary.py","MultipleExtend":["dspy.Signature"],"Imports":[{"Source":"dspy"},{"Source":"loguru","UsageName":["logger"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_function","UsageName":["ChapiUnoplatFunction"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_node","UsageName":["ChapiUnoplatNode"]}],"Position":{"StartLine":17,"StopLine":24},"Content":"class CodeConfluenceFunctionCallSummary(dspy.Signature):    \"\"\"This signature takes in existing summary of function and function call metadata (one at a time) and returns enhanced unoplat_function_final_summary.\"\"\"    function_call_json_schema: str = dspy.InputField(desc=\"This will contain json schema of the function call metadata\")    unoplat_function_existing_summary: str = dspy.InputField(default=\"Function Summary:\",desc=\"This will contain existing function summary which can be empty during first iteration.\")    chapi_function_call: str = dspy.InputField(desc=\"This will contain function call being made out of the function and its relevant metadata.\")    unoplat_function_final_summary: str = dspy.OutputField(desc=\"Refined and restructured final summary enhanced based on existing function summary, function metadata and function call metadata.\")"},{"NodeName":"CodeConfluenceFunctionSummaryWithClassSignature","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/dspy_function_summary.py","MultipleExtend":["dspy.Signature"],"Imports":[{"Source":"dspy"},{"Source":"loguru","UsageName":["logger"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_function","UsageName":["ChapiUnoplatFunction"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_node","UsageName":["ChapiUnoplatNode"]}],"Position":{"StartLine":24,"StopLine":31},"Content":"class CodeConfluenceFunctionSummaryWithClassSignature(dspy.Signature):    \"\"\"This signature takes in chapi_class_metadata and unoplat_function_existing_summary and returns enhanced final summary unoplat_function_final_summary.\"\"\"    class_json_schema: str = dspy.InputField(desc=\"This will contain json schema of the class metadata\")    chapi_class_metadata: str = dspy.InputField(desc=\"This will contain relevant class metadata in json\")    unoplat_function_existing_summary: str = dspy.InputField(desc=\"This will contain existing function summary without class metadata\")    unoplat_function_final_summary: str = dspy.OutputField(desc=\"This will contain final function summary enhanced using class metadata covering all important details\")"},{"NodeName":"CodeConfluenceFunctionObjectiveSignature","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/dspy_function_summary.py","MultipleExtend":["dspy.Signature"],"Imports":[{"Source":"dspy"},{"Source":"loguru","UsageName":["logger"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_function","UsageName":["ChapiUnoplatFunction"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_node","UsageName":["ChapiUnoplatNode"]}],"Position":{"StartLine":31,"StopLine":36},"Content":"class CodeConfluenceFunctionObjectiveSignature(dspy.Signature):    \"\"\"This signature takes in function_implementation description and returns function_objective of the function in a concise and accurate manner.\"\"\"    function_implementation: str = dspy.InputField(desc=\"This will contain concise detailed implementation description of the function\")    function_objective: str = dspy.OutputField(desc=\"This will contain concise objective of the function based on implementation summary within 3 lines without missing on any details.\")"},{"NodeName":"CodeConfluenceFunctionModule","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/dspy_function_summary.py","MultipleExtend":["dspy.Module"],"Functions":[{"Name":"__init__","FunctionCalls":[{"NodeName":"dspy","FunctionName":"TypedPredictor","Position":{"StartLine":43,"StartLinePosition":47,"StopLine":43,"StopLinePosition":103}}],"Position":{"StartLine":37,"StartLinePosition":4,"StopLine":45,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"function_json_schema","TypeType":""},{"TypeValue":"chapi_function_metadata","TypeType":""},{"TypeValue":"unoplat_function_summary","TypeType":""},{"TypeValue":"function_call_json_schema","TypeType":""},{"TypeValue":"unoplat_function_existing_summary","TypeType":""},{"TypeValue":"chapi_function_call","TypeType":""},{"TypeValue":"unoplat_function_final_summary","TypeType":""},{"TypeValue":"class_json_schema","TypeType":""},{"TypeValue":"chapi_class_metadata","TypeType":""},{"TypeValue":"function_implementation","TypeType":""},{"TypeValue":"function_objective","TypeType":""},{"TypeValue":"self.generate_function_summary","TypeType":"dspy"},{"TypeValue":"self.generate_function_call_summary","TypeType":"dspy"},{"TypeValue":"self.generate_function_summary_with_class_metadata","TypeType":"dspy"},{"TypeValue":"self.generate_function_objective","TypeType":"dspy"}],"Content":"def __init__(self):        super().__init__()        # TODO: change to typed chain of thought post dspy signature optimisers and also improve the summarisation part        self.generate_function_summary = dspy.TypedChainOfThought(CodeConfluenceFunctionSummary)        self.generate_function_call_summary = dspy.TypedChainOfThought(CodeConfluenceFunctionCallSummary)        self.generate_function_summary_with_class_metadata = dspy.TypedPredictor(CodeConfluenceFunctionSummaryWithClassSignature)        self.generate_function_objective = dspy.TypedPredictor(CodeConfluenceFunctionObjectiveSignature)    "},{"Name":"forward","Parameters":[{"TypeValue":"function_metadata","TypeType":"ChapiUnoplatFunction"},{"TypeValue":"class_metadata","TypeType":"ChapiUnoplatNode"}],"FunctionCalls":[{"NodeName":"self","FunctionName":"generate_function_objective","Position":{"StartLine":63,"StartLinePosition":49,"StopLine":63,"StopLinePosition":134}},{"NodeName":"self","FunctionName":"function_objective","Position":{"StartLine":63,"StartLinePosition":135,"StopLine":63,"StopLinePosition":136}}],"Position":{"StartLine":45,"StartLinePosition":4,"StopLine":66,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"function_json_schema","TypeType":""},{"TypeValue":"chapi_function_metadata","TypeType":""},{"TypeValue":"unoplat_function_summary","TypeType":""},{"TypeValue":"function_call_json_schema","TypeType":""},{"TypeValue":"unoplat_function_existing_summary","TypeType":""},{"TypeValue":"chapi_function_call","TypeType":""},{"TypeValue":"unoplat_function_final_summary","TypeType":""},{"TypeValue":"class_json_schema","TypeType":""},{"TypeValue":"chapi_class_metadata","TypeType":""},{"TypeValue":"function_implementation","TypeType":""},{"TypeValue":"function_objective","TypeType":""},{"TypeValue":"self.generate_function_summary","TypeType":"dspy"},{"TypeValue":"self.generate_function_call_summary","TypeType":"dspy"},{"TypeValue":"self.generate_function_summary_with_class_metadata","TypeType":"dspy"},{"TypeValue":"self.generate_function_objective","TypeType":"dspy"},{"TypeValue":"class_subset","TypeType":"str"},{"TypeValue":"function_subset","TypeType":"str"},{"TypeValue":"function_summary","TypeType":"self"},{"TypeValue":"current_function_call","TypeType":"str"},{"TypeValue":"code_confluence_function_summary","TypeType":"self"},{"TypeValue":"code_confluence_function_objective","TypeType":"self"}],"Content":"def forward(self, function_metadata: ChapiUnoplatFunction, class_metadata: ChapiUnoplatNode):        logger.debug(f\"Generating function summary for {function_metadata.name} present in class {class_metadata.node_name}\")                class_subset = str(class_metadata.model_dump_json(exclude_unset=True))        function_subset = str(function_metadata.model_dump_json(exclude_unset=True))                 function_summary = self.generate_function_summary(function_json_schema=function_subset.model_json_schema(),chapi_function_metadata=function_subset).unoplat_function_summary               for function_call in function_metadata.function_calls:            current_function_call = str(function_call.model_dump_json())                        if function_call.node_name == function_metadata.name:                continue            else:                function_summary = self.generate_function_call_summary(function_call_json_schema=current_function_call.model_json_schema(), unoplat_function_existing_summary=function_summary, chapi_function_call=current_function_call).unoplat_function_final_summary        code_confluence_function_summary = self.generate_function_summary_with_class_metadata( class_json_schema=class_subset.model_json_schema(), chapi_class_metadata=class_subset, unoplat_function_existing_summary=function_summary).unoplat_function_final_summary        code_confluence_function_objective = self.generate_function_objective(function_implementation=code_confluence_function_summary).function_objective                    return dspy.Prediction(objective=code_confluence_function_objective, implementation_summary=code_confluence_function_summary)    "}],"Imports":[{"Source":"dspy"},{"Source":"loguru","UsageName":["logger"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_function","UsageName":["ChapiUnoplatFunction"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_node","UsageName":["ChapiUnoplatNode"]}],"Position":{"StartLine":36,"StopLine":66,"StopLinePosition":4},"Content":"class CodeConfluenceFunctionModule(dspy.Module):    def __init__(self):        super().__init__()        # TODO: change to typed chain of thought post dspy signature optimisers and also improve the summarisation part        self.generate_function_summary = dspy.TypedChainOfThought(CodeConfluenceFunctionSummary)        self.generate_function_call_summary = dspy.TypedChainOfThought(CodeConfluenceFunctionCallSummary)        self.generate_function_summary_with_class_metadata = dspy.TypedPredictor(CodeConfluenceFunctionSummaryWithClassSignature)        self.generate_function_objective = dspy.TypedPredictor(CodeConfluenceFunctionObjectiveSignature)    def forward(self, function_metadata: ChapiUnoplatFunction, class_metadata: ChapiUnoplatNode):        logger.debug(f\"Generating function summary for {function_metadata.name} present in class {class_metadata.node_name}\")                class_subset = str(class_metadata.model_dump_json(exclude_unset=True))        function_subset = str(function_metadata.model_dump_json(exclude_unset=True))                 function_summary = self.generate_function_summary(function_json_schema=function_subset.model_json_schema(),chapi_function_metadata=function_subset).unoplat_function_summary               for function_call in function_metadata.function_calls:            current_function_call = str(function_call.model_dump_json())                        if function_call.node_name == function_metadata.name:                continue            else:                function_summary = self.generate_function_call_summary(function_call_json_schema=current_function_call.model_json_schema(), unoplat_function_existing_summary=function_summary, chapi_function_call=current_function_call).unoplat_function_final_summary        code_confluence_function_summary = self.generate_function_summary_with_class_metadata( class_json_schema=class_subset.model_json_schema(), chapi_class_metadata=class_subset, unoplat_function_existing_summary=function_summary).unoplat_function_final_summary        code_confluence_function_objective = self.generate_function_objective(function_implementation=code_confluence_function_summary).function_objective                    return dspy.Prediction(objective=code_confluence_function_objective, implementation_summary=code_confluence_function_summary)    "},{"NodeName":"CodeConfluenceClassSummarySignature","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/dspy_class_summary.py","MultipleExtend":["dspy.Signature"],"Imports":[{"Source":"typing","UsageName":["List"]},{"Source":"dspy"},{"Source":"loguru","UsageName":["logger"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_node","UsageName":["ChapiUnoplatNode"]},{"Source":"unoplat_code_confluence.data_models.dspy.dspy_unoplat_function_summary","UsageName":["DspyUnoplatFunctionSummary"]},{"Source":"unoplat_code_confluence.data_models.dspy.dspy_unoplat_node_summary","UsageName":["DspyUnoplatNodeSummary"]}],"Position":{"StartLine":15,"StopLine":24},"Content":"class CodeConfluenceClassSummarySignature(dspy.Signature):    \"\"\"This signature takes in existing summary of a class and function summary of a class one at a time and returns enhanced final_class_summary.\"\"\"    class_existing_summary: str = dspy.InputField(default=\"Summary:\",desc=\"This will contain existing class summary\")    function_summary: str = dspy.InputField(desc=\"This will contain current function summary based on which existing class summary has to be improved\")    class_json_schema: str = dspy.InputField(desc=\"This will contain json schema of the class metadata\")    class_metadata: str = dspy.InputField(desc=\"This will contain relevant current class metadata\")    final_class_summary: str = dspy.OutputField(desc=\"This will contain improved concise class summary\")    "},{"NodeName":"CodeConfluenceClassObjectiveSignature","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/dspy_class_summary.py","MultipleExtend":["dspy.Signature"],"Imports":[{"Source":"typing","UsageName":["List"]},{"Source":"dspy"},{"Source":"loguru","UsageName":["logger"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_node","UsageName":["ChapiUnoplatNode"]},{"Source":"unoplat_code_confluence.data_models.dspy.dspy_unoplat_function_summary","UsageName":["DspyUnoplatFunctionSummary"]},{"Source":"unoplat_code_confluence.data_models.dspy.dspy_unoplat_node_summary","UsageName":["DspyUnoplatNodeSummary"]}],"Position":{"StartLine":24,"StopLine":30},"Content":"class CodeConfluenceClassObjectiveSignature(dspy.Signature):    \"\"\"This signature takes in class summary and returns concise class_objective of the class. Do not include your reasoning in class_objective.\"\"\"    final_class_summary: str = dspy.InputField(desc=\"This should contain concise detailed implementation summary of the class or in some cases direct content of the class if it is just a data model object.\")    class_objective: str = dspy.OutputField(desc=\"This should contain concise objective of the class based on implementation summary in under 2 lines without loosing on any details\")   "},{"NodeName":"CodeConfluenceClassModule","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/dspy_class_summary.py","MultipleExtend":["dspy.Module"],"Functions":[{"Name":"__init__","FunctionCalls":[{"NodeName":"dspy","FunctionName":"ChainOfThoughtWithHint","Position":{"StartLine":34,"StartLinePosition":44,"StopLine":34,"StopLinePosition":105}}],"Position":{"StartLine":31,"StartLinePosition":4,"StopLine":36,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"class_existing_summary","TypeType":""},{"TypeValue":"function_summary","TypeType":""},{"TypeValue":"class_json_schema","TypeType":""},{"TypeValue":"class_metadata","TypeType":""},{"TypeValue":"final_class_summary","TypeType":""},{"TypeValue":"class_objective","TypeType":""},{"TypeValue":"self.generate_class_summary","TypeType":"dspy"},{"TypeValue":"self.generate_class_objective","TypeType":"dspy"}],"Content":"def __init__(self):        super().__init__()        self.generate_class_summary = dspy.ChainOfThoughtWithHint(CodeConfluenceClassSummarySignature)        self.generate_class_objective = dspy.ChainOfThoughtWithHint(CodeConfluenceClassObjectiveSignature)    "},{"Name":"forward","Parameters":[{"TypeValue":"class_metadata","TypeType":"ChapiUnoplatNode"},{"TypeValue":"function_objective_summary","TypeType":"List[DspyUnoplatFunctionSummary]"}],"FunctionCalls":[{"FunctionName":"DspyUnoplatNodeSummary","Position":{"StartLine":54,"StartLinePosition":51,"StopLine":54,"StopLinePosition":212}}],"Position":{"StartLine":36,"StartLinePosition":4,"StopLine":62,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"class_existing_summary","TypeType":""},{"TypeValue":"function_summary","TypeType":""},{"TypeValue":"class_json_schema","TypeType":""},{"TypeValue":"class_metadata","TypeType":""},{"TypeValue":"final_class_summary","TypeType":""},{"TypeValue":"class_objective","TypeType":""},{"TypeValue":"self.generate_class_summary","TypeType":"dspy"},{"TypeValue":"self.generate_class_objective","TypeType":"dspy"},{"TypeValue":"class_summary","TypeType":"signature_class_summary"},{"TypeValue":"signature_class_summary","TypeType":"self"},{"TypeValue":"hint","TypeType":"\"Generate the class objective for the class by being concise and dnt miss on any details.\""},{"TypeValue":"class_objective_signature","TypeType":"self"},{"TypeValue":"dspy_class_summary","TypeType":"DspyUnoplatNodeSummary"}],"Content":"def forward(self, class_metadata: ChapiUnoplatNode, function_objective_summary: List[DspyUnoplatFunctionSummary]):        logger.debug(f\"Generating class summary for {class_metadata.node_name}\")        class_summary = \"\"            for function_objective in function_objective_summary:            signature_class_summary = self.generate_class_summary(class_existing_summary=class_summary, function_summary=function_objective.objective, class_json_schema=class_metadata.model_json_schema(), class_metadata=str(class_metadata.model_dump_json()),hint=\"Generate the class detailed summary for the class by being concise , factual and grounded.:\"+class_metadata.node_name)            class_summary = signature_class_summary.final_class_summary            if class_metadata.node_name is not None:            hint=\"Generate the class objective for the class by being concise and dnt miss on any details.:\"+class_metadata.node_name        else:            hint=\"Generate the class objective for the class by being concise and dnt miss on any details.\"                if len(function_objective_summary) > 0:            class_objective_signature = self.generate_class_objective(final_class_summary = class_summary,hint=hint)        else:            class_objective_signature = self.generate_class_objective(final_class_summary = class_metadata.content,hint=hint)        dspy_class_summary = DspyUnoplatNodeSummary(NodeName=class_metadata.node_name,NodeObjective=class_objective_signature.class_objective, NodeSummary=class_summary,FunctionsSummary=function_objective_summary)                return dspy.Prediction(answer=dspy_class_summary)                             "}],"Imports":[{"Source":"typing","UsageName":["List"]},{"Source":"dspy"},{"Source":"loguru","UsageName":["logger"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_node","UsageName":["ChapiUnoplatNode"]},{"Source":"unoplat_code_confluence.data_models.dspy.dspy_unoplat_function_summary","UsageName":["DspyUnoplatFunctionSummary"]},{"Source":"unoplat_code_confluence.data_models.dspy.dspy_unoplat_node_summary","UsageName":["DspyUnoplatNodeSummary"]}],"Position":{"StartLine":30,"StopLine":62,"StopLinePosition":4},"Content":"class CodeConfluenceClassModule(dspy.Module):    def __init__(self):        super().__init__()        self.generate_class_summary = dspy.ChainOfThoughtWithHint(CodeConfluenceClassSummarySignature)        self.generate_class_objective = dspy.ChainOfThoughtWithHint(CodeConfluenceClassObjectiveSignature)    def forward(self, class_metadata: ChapiUnoplatNode, function_objective_summary: List[DspyUnoplatFunctionSummary]):        logger.debug(f\"Generating class summary for {class_metadata.node_name}\")        class_summary = \"\"            for function_objective in function_objective_summary:            signature_class_summary = self.generate_class_summary(class_existing_summary=class_summary, function_summary=function_objective.objective, class_json_schema=class_metadata.model_json_schema(), class_metadata=str(class_metadata.model_dump_json()),hint=\"Generate the class detailed summary for the class by being concise , factual and grounded.:\"+class_metadata.node_name)            class_summary = signature_class_summary.final_class_summary            if class_metadata.node_name is not None:            hint=\"Generate the class objective for the class by being concise and dnt miss on any details.:\"+class_metadata.node_name        else:            hint=\"Generate the class objective for the class by being concise and dnt miss on any details.\"                if len(function_objective_summary) > 0:            class_objective_signature = self.generate_class_objective(final_class_summary = class_summary,hint=hint)        else:            class_objective_signature = self.generate_class_objective(final_class_summary = class_metadata.content,hint=hint)        dspy_class_summary = DspyUnoplatNodeSummary(NodeName=class_metadata.node_name,NodeObjective=class_objective_signature.class_objective, NodeSummary=class_summary,FunctionsSummary=function_objective_summary)                return dspy.Prediction(answer=dspy_class_summary)                             "},{"NodeName":"UnoplatEmbeddingGenerator","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/embedding/unoplat_embedding_gen.py","Functions":[{"Name":"__init__","Parameters":[{"TypeValue":"config","TypeType":"AppConfig"}],"FunctionCalls":[{"NodeName":"self","FunctionName":"model","Position":{"StartLine":14,"StartLinePosition":30,"StopLine":14,"StopLinePosition":31}},{"NodeName":"self","FunctionName":"get_sentence_embedding_dimension","Position":{"StartLine":14,"StartLinePosition":36,"StopLine":14,"StopLinePosition":70}}],"Position":{"StartLine":12,"StartLinePosition":4,"StopLine":16,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"self.model","TypeType":"SentenceTransformer"},{"TypeValue":"self.dimensions","TypeType":"self"}],"Content":"def __init__(self, config: AppConfig):        self.model = SentenceTransformer(config.sentence_transformer_model, trust_remote_code=True)        self.dimensions = self.model.get_sentence_embedding_dimension()    "},{"Name":"generate_embeddings","Parameters":[{"TypeValue":"texts","TypeType":"List[str]"}],"Position":{"StartLine":16,"StartLinePosition":4,"StopLine":20,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"self.model","TypeType":"SentenceTransformer"},{"TypeValue":"self.dimensions","TypeType":"self"},{"TypeValue":"task","TypeType":"'retrieval.query'"}],"Content":"def generate_embeddings(self, texts: List[str]) -> List[List[float]]:        task = 'retrieval.query'        return self.model.encode(texts, task=task).tolist()       "},{"Name":"generate_embeddings_for_single_text","Parameters":[{"TypeValue":"text","TypeType":"str"}],"Position":{"StartLine":20,"StartLinePosition":4,"StopLine":24,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"self.model","TypeType":"SentenceTransformer"},{"TypeValue":"self.dimensions","TypeType":"self"},{"TypeValue":"task","TypeType":"'retrieval.query'"}],"Content":"def generate_embeddings_for_single_text(self, text: str) -> List[float]:        task = 'retrieval.query'        return self.model.encode(text, task=task).tolist()        "},{"Name":"get_dimensions","Position":{"StartLine":24,"StartLinePosition":4,"StopLine":27},"LocalVariables":[{"TypeValue":"self.model","TypeType":"SentenceTransformer"},{"TypeValue":"self.dimensions","TypeType":"self"},{"TypeValue":"task","TypeType":"'retrieval.query'"}],"Content":"def get_dimensions(self) -> int:        return self.dimensions"}],"Imports":[{"Source":"typing","UsageName":["List"]},{"Source":"sentence_transformers","UsageName":["SentenceTransformer"]},{"Source":"unoplat_code_confluence.configuration.external_config","UsageName":["AppConfig"]}],"Position":{"StartLine":11,"StopLine":27},"Content":"class UnoplatEmbeddingGenerator:    def __init__(self, config: AppConfig):        self.model = SentenceTransformer(config.sentence_transformer_model, trust_remote_code=True)        self.dimensions = self.model.get_sentence_embedding_dimension()    def generate_embeddings(self, texts: List[str]) -> List[List[float]]:        task = 'retrieval.query'        return self.model.encode(texts, task=task).tolist()       def generate_embeddings_for_single_text(self, text: str) -> List[float]:        task = 'retrieval.query'        return self.model.encode(text, task=task).tolist()        def get_dimensions(self) -> int:        return self.dimensions"},{"NodeName":"Downloader","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/downloader/downloader.py","Functions":[{"Name":"get_specific_release_info","Parameters":[{"TypeValue":"repo_name","TypeType":""},{"TypeValue":"release_tag","TypeType":""},{"DefaultValue":"None","TypeValue":"github_token","TypeType":""}],"FunctionCalls":[{"NodeName":"logger","FunctionName":"info","Position":{"StartLine":19,"StartLinePosition":14,"StopLine":19,"StopLinePosition":72}}],"Annotations":[{"Name":"staticmethod","Position":{"StartLine":13,"StartLinePosition":4,"StopLine":14,"StopLinePosition":4}}],"Position":{"StartLine":14,"StartLinePosition":4,"StopLine":22,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"g","TypeType":"Github"},{"TypeValue":"repo","TypeType":"g"},{"TypeValue":"specific_release","TypeType":"repo"}],"Content":"def get_specific_release_info(repo_name, release_tag, github_token=None):        logger.info(f\"Fetching release info for repository: {repo_name} with tag: {release_tag}\")        g = Github(github_token) if github_token else Github()  # Optionally use a token for higher rate limits: Github(\"your_github_access_token\")        repo = g.get_repo(repo_name)        specific_release = repo.get_release(release_tag)        logger.info(f\"Specific release tag: {specific_release.tag_name}\")        return specific_release.tag_name, specific_release.get_assets()    "},{"Name":"download_file","Parameters":[{"TypeValue":"url","TypeType":""},{"TypeValue":"download_dir","TypeType":""},{"TypeValue":"filename","TypeType":""}],"FunctionCalls":[{"NodeName":"logger","FunctionName":"info","Position":{"StartLine":39,"StartLinePosition":14,"StopLine":39,"StopLinePosition":69}}],"Annotations":[{"Name":"staticmethod","Position":{"StartLine":22,"StartLinePosition":4,"StopLine":23,"StopLinePosition":4}}],"Position":{"StartLine":23,"StartLinePosition":4,"StopLine":42,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"g","TypeType":"Github"},{"TypeValue":"repo","TypeType":"g"},{"TypeValue":"specific_release","TypeType":"repo"},{"TypeValue":"local_filename","TypeType":"os"},{"TypeValue":"response","TypeType":"requests"},{"TypeValue":"total_size_in_bytes","TypeType":"int"},{"TypeValue":"block_size","TypeType":"1024"},{"TypeValue":"progress_bar","TypeType":"tqdm"}],"Content":"def download_file(url, download_dir, filename):        logger.info(f\"Downloading file from URL: {url} to directory: {download_dir}\")        os.makedirs(download_dir, exist_ok=True)  # Ensure the directory exists        local_filename = os.path.join(download_dir, filename)        response = requests.get(url, stream=True)        total_size_in_bytes = int(response.headers.get('content-length', 0))        block_size = 1024  # 1 Kibibyte        progress_bar = tqdm(total=total_size_in_bytes, unit='iB', unit_scale=True)        with open(local_filename, 'wb') as file:            for data in response.iter_content(block_size):                progress_bar.update(len(data))                file.write(data)        progress_bar.close()        if total_size_in_bytes != 0 and progress_bar.n != total_size_in_bytes:            logger.error(\"ERROR, something went wrong during file download\")        logger.info(f\"File downloaded successfully: {local_filename}\")        return local_filename    "},{"Name":"download_latest_jar","Parameters":[{"TypeValue":"repo_name","TypeType":""},{"TypeValue":"download_dir","TypeType":""},{"DefaultValue":"None","TypeValue":"github_token","TypeType":""}],"FunctionCalls":[{"NodeName":"logger","FunctionName":"info","Position":{"StartLine":64,"StartLinePosition":14,"StopLine":64,"StopLinePosition":84}}],"Annotations":[{"Name":"staticmethod","Position":{"StartLine":42,"StartLinePosition":4,"StopLine":43,"StopLinePosition":4}}],"Position":{"StartLine":43,"StartLinePosition":4,"StopLine":65,"StopLinePosition":108},"LocalVariables":[{"TypeValue":"g","TypeType":"Github"},{"TypeValue":"repo","TypeType":"g"},{"TypeValue":"specific_release","TypeType":"repo"},{"TypeValue":"local_filename","TypeType":"os"},{"TypeValue":"response","TypeType":"requests"},{"TypeValue":"total_size_in_bytes","TypeType":"int"},{"TypeValue":"block_size","TypeType":"1024"},{"TypeValue":"progress_bar","TypeType":"tqdm"},{"TypeValue":"","TypeType":"Downloader"},{"TypeValue":"jar_pattern","TypeType":"re"},{"TypeValue":"jar_asset","TypeType":"next"},{"TypeValue":"highest_version_asset_name","TypeType":"jar_asset"},{"TypeValue":"highest_version_asset_url","TypeType":"jar_asset"},{"TypeValue":"existing_jars","TypeType":"[fforfinos.listdir(download_dir)ifjar_pattern.match(f)]"},{"TypeValue":"matching_jar","TypeType":"next"}],"Content":"def download_latest_jar(repo_name, download_dir, github_token=None):        logger.info(f\"Downloading latest JAR for repository: {repo_name}\")        #todo: make this dynamic but there are breaking upstream changes as of now so hardcoding for now.        tag_name, assets = Downloader.get_specific_release_info(repo_name, 'v2.1.5',github_token)        jar_pattern = re.compile(r\"scanner_cli-(.*)-all\\.jar\")  # Regex to match the jar file        jar_asset = next((asset for asset in assets if jar_pattern.match(asset.name)), None)        if not jar_asset:            logger.error(\"No matching .jar file found in the latest release assets.\")            raise FileNotFoundError(\"No matching .jar file found in the latest release assets.\")                highest_version_asset_name = jar_asset.name        highest_version_asset_url = jar_asset.browser_download_url        existing_jars = [f for f in os.listdir(download_dir) if jar_pattern.match(f)]        if existing_jars:            matching_jar = next((jar for jar in existing_jars if tag_name[1:] in jar), None)            if matching_jar:                logger.info(f\"Using existing JAR for version {tag_name}: {matching_jar}\")                return os.path.join(download_dir, matching_jar)                # If no local JAR is higher version, download the latest        logger.info(f\"JAR found: {highest_version_asset_name}, starting download...\")        return Downloader.download_file(highest_version_asset_url, download_dir, highest_version_asset_name)"}],"Imports":[{"Source":"os"},{"Source":"re"},{"Source":"requests"},{"Source":"github","UsageName":["Github"]},{"Source":"loguru","UsageName":["logger"]},{"Source":"tqdm","UsageName":["tqdm"]}],"Position":{"StartLine":12,"StopLine":65,"StopLinePosition":108},"Content":"class Downloader:    @staticmethod    def get_specific_release_info(repo_name, release_tag, github_token=None):        logger.info(f\"Fetching release info for repository: {repo_name} with tag: {release_tag}\")        g = Github(github_token) if github_token else Github()  # Optionally use a token for higher rate limits: Github(\"your_github_access_token\")        repo = g.get_repo(repo_name)        specific_release = repo.get_release(release_tag)        logger.info(f\"Specific release tag: {specific_release.tag_name}\")        return specific_release.tag_name, specific_release.get_assets()    @staticmethod    def download_file(url, download_dir, filename):        logger.info(f\"Downloading file from URL: {url} to directory: {download_dir}\")        os.makedirs(download_dir, exist_ok=True)  # Ensure the directory exists        local_filename = os.path.join(download_dir, filename)        response = requests.get(url, stream=True)        total_size_in_bytes = int(response.headers.get('content-length', 0))        block_size = 1024  # 1 Kibibyte        progress_bar = tqdm(total=total_size_in_bytes, unit='iB', unit_scale=True)        with open(local_filename, 'wb') as file:            for data in response.iter_content(block_size):                progress_bar.update(len(data))                file.write(data)        progress_bar.close()        if total_size_in_bytes != 0 and progress_bar.n != total_size_in_bytes:            logger.error(\"ERROR, something went wrong during file download\")        logger.info(f\"File downloaded successfully: {local_filename}\")        return local_filename    @staticmethod    def download_latest_jar(repo_name, download_dir, github_token=None):        logger.info(f\"Downloading latest JAR for repository: {repo_name}\")        #todo: make this dynamic but there are breaking upstream changes as of now so hardcoding for now.        tag_name, assets = Downloader.get_specific_release_info(repo_name, 'v2.1.5',github_token)        jar_pattern = re.compile(r\"scanner_cli-(.*)-all\\.jar\")  # Regex to match the jar file        jar_asset = next((asset for asset in assets if jar_pattern.match(asset.name)), None)        if not jar_asset:            logger.error(\"No matching .jar file found in the latest release assets.\")            raise FileNotFoundError(\"No matching .jar file found in the latest release assets.\")                highest_version_asset_name = jar_asset.name        highest_version_asset_url = jar_asset.browser_download_url        existing_jars = [f for f in os.listdir(download_dir) if jar_pattern.match(f)]        if existing_jars:            matching_jar = next((jar for jar in existing_jars if tag_name[1:] in jar), None)            if matching_jar:                logger.info(f\"Using existing JAR for version {tag_name}: {matching_jar}\")                return os.path.join(download_dir, matching_jar)                # If no local JAR is higher version, download the latest        logger.info(f\"JAR found: {highest_version_asset_name}, starting download...\")        return Downloader.download_file(highest_version_asset_url, download_dir, highest_version_asset_name)"},{"NodeName":"CodeConfluenceCodebaseSignature","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/dspy_codebase_summary.py","MultipleExtend":["dspy.Signature"],"Imports":[{"Source":"typing","UsageName":["Dict"]},{"Source":"dspy"},{"Source":"unoplat_code_confluence.data_models.dspy.dspy_unoplat_package_summary","UsageName":["DspyUnoplatPackageSummary"]}],"Position":{"StartLine":12,"StopLine":19},"Content":"class CodeConfluenceCodebaseSignature(dspy.Signature):    \"\"\"This signature takes in existing summary of a codebase and package objective of a package one at a time and refines codebase_existing_summary with factual and grounded insights based on package_objective and returns final_codebase_summary as enhanced final summary of codebase.\"\"\"    codebase_existing_summary: str = dspy.InputField(alias=\"codebase_existing_summary\",default=\"codebase existing summary:\",desc=\"This will contain existing codebase summary\")    package_objective: str = dspy.InputField(alias=\"package_objective\",desc=\"This will contain current package objective based on which final_codebase_summary has to be improved\")    final_codebase_summary: str = dspy.OutputField(alias=\"final_codebase_summary\",desc=\"This will contain final improved concise codebase summary\")    "},{"NodeName":"CodeConfluenceCodebaseObjectiveSignature","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/dspy_codebase_summary.py","MultipleExtend":["dspy.Signature"],"Imports":[{"Source":"typing","UsageName":["Dict"]},{"Source":"dspy"},{"Source":"unoplat_code_confluence.data_models.dspy.dspy_unoplat_package_summary","UsageName":["DspyUnoplatPackageSummary"]}],"Position":{"StartLine":19,"StopLine":24},"Content":"class CodeConfluenceCodebaseObjectiveSignature(dspy.Signature):    \"\"\"This signature takes in codebase summary and returns codebase_objective as concise objective of the codebase. Do not include your reasoning in codebase_objective.\"\"\"    final_codebase_summary: str = dspy.InputField(alias=\"final_codebase_summary\",desc=\"This will contain concise detailed implementation summary of the codebase\")    codebase_objective: str = dspy.OutputField(alias=\"codebase_objective\",desc=\"This will contain concise objective of the codebase based on detailed codebase summary\")"},{"NodeName":"CodeConfluenceCodebaseModule","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/dspy_codebase_summary.py","MultipleExtend":["dspy.Module"],"Functions":[{"Name":"__init__","FunctionCalls":[{"NodeName":"dspy","FunctionName":"ChainOfThoughtWithHint","Position":{"StartLine":28,"StartLinePosition":47,"StopLine":28,"StopLinePosition":111}}],"Position":{"StartLine":25,"StartLinePosition":4,"StopLine":31,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"codebase_existing_summary","TypeType":""},{"TypeValue":"package_objective","TypeType":""},{"TypeValue":"final_codebase_summary","TypeType":""},{"TypeValue":"codebase_objective","TypeType":""},{"TypeValue":"self.generate_codebase_summary","TypeType":"dspy"},{"TypeValue":"self.generate_codebase_objective","TypeType":"dspy"}],"Content":"def __init__(self):        super().__init__()        self.generate_codebase_summary = dspy.ChainOfThoughtWithHint(CodeConfluenceCodebaseSignature)        self.generate_codebase_objective = dspy.ChainOfThoughtWithHint(CodeConfluenceCodebaseObjectiveSignature)            "},{"Name":"forward","Parameters":[{"TypeValue":"package_objective_dict","TypeType":"Dict[str,DspyUnoplatPackageSummary]"}],"Position":{"StartLine":31,"StartLinePosition":4,"StopLine":47,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"codebase_existing_summary","TypeType":""},{"TypeValue":"package_objective","TypeType":""},{"TypeValue":"final_codebase_summary","TypeType":""},{"TypeValue":"codebase_objective","TypeType":""},{"TypeValue":"self.generate_codebase_summary","TypeType":"dspy"},{"TypeValue":"self.generate_codebase_objective","TypeType":"dspy"},{"TypeValue":"codebase_summary","TypeType":"signature_package_summary"},{"TypeValue":"summary_hint","TypeType":"\"Enhance the existing codebase summary based on current package objective without loosing important details from existing codebase summary. So be cautious while being concise. \""},{"TypeValue":"signature_package_summary","TypeType":""},{"TypeValue":"codebase_objective_hint","TypeType":"\"Capture all important highlights from summary and then generate the codebase objective in structured manner for the codebase by being concise but cautious to not miss any important details.\""},{"TypeValue":"codebase_objective_signature","TypeType":""}],"Content":"def forward(self, package_objective_dict: Dict[str, DspyUnoplatPackageSummary]):        codebase_summary = \"\"        summary_hint=\"Enhance the existing codebase summary based on current package objective without loosing important details from existing codebase summary. So be cautious while being concise. \"        for _,package_metadata in package_objective_dict.items():            signature_package_summary: CodeConfluenceCodebaseSignature = self.generate_codebase_summary(codebase_existing_summary=codebase_summary, package_objective=package_metadata.package_objective,hint=summary_hint)            codebase_summary = signature_package_summary.final_codebase_summary                    codebase_objective_hint=\"Capture all important highlights from summary and then generate the codebase objective in structured manner for the codebase by being concise but cautious to not miss any important details.\"            codebase_objective_signature: CodeConfluenceCodebaseObjectiveSignature = self.generate_codebase_objective(final_codebase_summary=codebase_summary,hint=codebase_objective_hint)        return dspy.Prediction(answer=codebase_objective_signature.codebase_objective,summary=codebase_summary)                            "}],"Imports":[{"Source":"typing","UsageName":["Dict"]},{"Source":"dspy"},{"Source":"unoplat_code_confluence.data_models.dspy.dspy_unoplat_package_summary","UsageName":["DspyUnoplatPackageSummary"]}],"Position":{"StartLine":24,"StopLine":47,"StopLinePosition":4},"Content":"class CodeConfluenceCodebaseModule(dspy.Module):    def __init__(self):        super().__init__()        self.generate_codebase_summary = dspy.ChainOfThoughtWithHint(CodeConfluenceCodebaseSignature)        self.generate_codebase_objective = dspy.ChainOfThoughtWithHint(CodeConfluenceCodebaseObjectiveSignature)            def forward(self, package_objective_dict: Dict[str, DspyUnoplatPackageSummary]):        codebase_summary = \"\"        summary_hint=\"Enhance the existing codebase summary based on current package objective without loosing important details from existing codebase summary. So be cautious while being concise. \"        for _,package_metadata in package_objective_dict.items():            signature_package_summary: CodeConfluenceCodebaseSignature = self.generate_codebase_summary(codebase_existing_summary=codebase_summary, package_objective=package_metadata.package_objective,hint=summary_hint)            codebase_summary = signature_package_summary.final_codebase_summary                    codebase_objective_hint=\"Capture all important highlights from summary and then generate the codebase objective in structured manner for the codebase by being concise but cautious to not miss any important details.\"            codebase_objective_signature: CodeConfluenceCodebaseObjectiveSignature = self.generate_codebase_objective(final_codebase_summary=codebase_summary,hint=codebase_objective_hint)        return dspy.Prediction(answer=codebase_objective_signature.codebase_objective,summary=codebase_summary)                            "},{"NodeName":"ILoadJson","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/loader/iload_json.py","MultipleExtend":["ABC"],"Functions":[{"Name":"load_json_from_file","Parameters":[{"TypeValue":"file_path","TypeType":"str"}],"Annotations":[{"Name":"abstractmethod","Position":{"StartLine":7,"StartLinePosition":4,"StopLine":8,"StopLinePosition":4}}],"Position":{"StartLine":8,"StartLinePosition":4,"StopLine":10,"StopLinePosition":12},"Content":"def load_json_from_file(self, file_path: str) -> json:        \"\"\"Load JSON data from a file and return a JSON object.\"\"\"        pass"}],"Imports":[{"Source":"json"},{"Source":"abc","UsageName":["ABC","abstractmethod"]}],"Position":{"StartLine":6,"StopLine":10,"StopLinePosition":12},"Content":"class ILoadJson(ABC):    @abstractmethod    def load_json_from_file(self, file_path: str) -> json:        \"\"\"Load JSON data from a file and return a JSON object.\"\"\"        pass"},{"NodeName":"IParseJson","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/loader/iparse_json.py","MultipleExtend":["ABC"],"Functions":[{"Name":"parse_json_to_nodes","Parameters":[{"TypeValue":"json_data","TypeType":"dict"},{"TypeValue":"local_workspace_path","TypeType":"str"},{"TypeValue":"programming_language","TypeType":"str"}],"Annotations":[{"Name":"abstractmethod","Position":{"StartLine":10,"StartLinePosition":4,"StopLine":11,"StopLinePosition":4}}],"Position":{"StartLine":11,"StartLinePosition":4,"StopLine":14},"Content":"def parse_json_to_nodes(self, json_data: dict, local_workspace_path: str, programming_language: str) -> List[ChapiUnoplatNode]:        \"\"\"Parses JSON data into a list of Node objects.\"\"\"        pass"}],"Imports":[{"Source":"abc","UsageName":["ABC","abstractmethod"]},{"Source":"typing","UsageName":["List"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_node","UsageName":["ChapiUnoplatNode"]}],"Position":{"StartLine":9,"StopLine":14},"Content":"class IParseJson(ABC):    @abstractmethod    def parse_json_to_nodes(self, json_data: dict, local_workspace_path: str, programming_language: str) -> List[ChapiUnoplatNode]:        \"\"\"Parses JSON data into a list of Node objects.\"\"\"        pass"},{"NodeName":"JsonLoader","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/loader/json_loader.py","MultipleExtend":["ILoadJson"],"Functions":[{"Name":"load_json_from_file","Parameters":[{"TypeValue":"file_path","TypeType":"str"}],"FunctionCalls":[{"NodeName":"logger","FunctionName":"error","Position":{"StartLine":36,"StartLinePosition":18,"StopLine":36,"StopLinePosition":74}}],"Annotations":[{"Name":"logger.catch","Position":{"StartLine":12,"StartLinePosition":4,"StopLine":13,"StopLinePosition":4}}],"Position":{"StartLine":13,"StartLinePosition":4,"StopLine":39},"LocalVariables":[{"TypeValue":"data","TypeType":"json"}],"Content":"def load_json_from_file(self, file_path: str) -> json:        \"\"\"        Load JSON data from a file and return the JSON object.        This method uses Loguru for enhanced logging and exception handling. It attempts to open and read        a JSON file specified by the file_path argument. If successful, it logs the success and returns the data.        If an exception occurs, it logs the error and re-raises the exception.        Args:            file_path (str): The path to the JSON file to be loaded.        Returns:            json: The JSON object loaded from the file.        Raises:            Exception: Propagates any exceptions that occur during file opening or JSON loading.        \"\"\"        try:            with open(file_path, 'r') as file:                data = json.load(file)            logger.info(f\"JSON data successfully loaded from {file_path}\")            return data        except Exception as e:            logger.error(f\"Failed to load JSON data from {file_path}: {e}\")            raise"}],"Imports":[{"Source":"json"},{"Source":"loguru","UsageName":["logger"]},{"Source":"unoplat_code_confluence.loader.iload_json","UsageName":["ILoadJson"]}],"Position":{"StartLine":11,"StopLine":39},"Content":"class JsonLoader(ILoadJson):    @logger.catch    def load_json_from_file(self, file_path: str) -> json:        \"\"\"        Load JSON data from a file and return the JSON object.        This method uses Loguru for enhanced logging and exception handling. It attempts to open and read        a JSON file specified by the file_path argument. If successful, it logs the success and returns the data.        If an exception occurs, it logs the error and re-raises the exception.        Args:            file_path (str): The path to the JSON file to be loaded.        Returns:            json: The JSON object loaded from the file.        Raises:            Exception: Propagates any exceptions that occur during file opening or JSON loading.        \"\"\"        try:            with open(file_path, 'r') as file:                data = json.load(file)            logger.info(f\"JSON data successfully loaded from {file_path}\")            return data        except Exception as e:            logger.error(f\"Failed to load JSON data from {file_path}: {e}\")            raise"},{"NodeName":"JsonParser","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/loader/parse_json.py","MultipleExtend":["IParseJson"],"Functions":[{"Name":"parse_json_to_nodes","Parameters":[{"TypeValue":"json_data","TypeType":"dict"},{"TypeValue":"local_workspace_path","TypeType":"str"},{"TypeValue":"programming_language","TypeType":"str"}],"Position":{"StartLine":16,"StartLinePosition":4,"StopLine":56,"StopLinePosition":31},"LocalVariables":[{"TypeValue":"unoplat_codebase","TypeType":"UnoplatCodebase"},{"TypeValue":"unoplat_package_dict","TypeType":""},{"TypeValue":"node","TypeType":"ChapiUnoplatNode"},{"TypeValue":"node.node_name","TypeType":"os"},{"TypeValue":"relative_path","TypeType":"os"},{"TypeValue":"node.package","TypeType":"node"},{"TypeValue":"package_parts","TypeType":"node"},{"TypeValue":"current_package","TypeType":"current_package"},{"TypeValue":"full_package_name","TypeType":"part"},{"TypeValue":"current_package[full_package_name]","TypeType":"UnoplatPackage"},{"TypeValue":"unoplat_codebase.packages","TypeType":"unoplat_package_dict"}],"Content":"def parse_json_to_nodes(self, json_data: dict, local_workspace_path: str, programming_language: str) -> UnoplatCodebase:        \"\"\"Concrete implementation of the parse_json_to_nodes method.\"\"\"        unoplat_codebase = UnoplatCodebase()                        unoplat_package_dict: Dict[str,UnoplatPackage] = {}                for item in json_data:            try:                                node = ChapiUnoplatNode.model_validate(item)                                if node.node_name == \"default\":                    node.node_name = os.path.basename(node.file_path).split('.')[0]                                if programming_language.lower() == 'python':                    relative_path = os.path.relpath(node.file_path, local_workspace_path)                    node.package = os.path.dirname(relative_path).replace(os.path.sep, '.')                    node.package = node.package if node.package else 'root'                                                package_parts = node.package.split('.')                current_package = unoplat_package_dict                full_package_name = \"\"                for i, part in enumerate(package_parts):                    full_package_name = part if i == 0 else f\"{full_package_name}.{part}\"                    if full_package_name not in current_package:                        current_package[full_package_name] = UnoplatPackage(name=full_package_name)                    if i == len(package_parts) - 1:                        current_package[full_package_name].nodes.append(node)                    else:                        current_package = current_package[full_package_name].sub_packages                                                    except Exception as e:                logger.error(f\"Error processing node: {e}\")        unoplat_codebase.packages =  unoplat_package_dict                return unoplat_codebase"}],"Imports":[{"Source":"os"},{"Source":"typing","UsageName":["Dict"]},{"Source":"loguru","UsageName":["logger"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_codebase","UsageName":["UnoplatCodebase"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_node","UsageName":["ChapiUnoplatNode"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_package","UsageName":["UnoplatPackage"]},{"Source":"unoplat_code_confluence.loader.iparse_json","UsageName":["IParseJson"]}],"Position":{"StartLine":15,"StopLine":56,"StopLinePosition":31},"Content":"class JsonParser(IParseJson):    def parse_json_to_nodes(self, json_data: dict, local_workspace_path: str, programming_language: str) -> UnoplatCodebase:        \"\"\"Concrete implementation of the parse_json_to_nodes method.\"\"\"        unoplat_codebase = UnoplatCodebase()                        unoplat_package_dict: Dict[str,UnoplatPackage] = {}                for item in json_data:            try:                                node = ChapiUnoplatNode.model_validate(item)                                if node.node_name == \"default\":                    node.node_name = os.path.basename(node.file_path).split('.')[0]                                if programming_language.lower() == 'python':                    relative_path = os.path.relpath(node.file_path, local_workspace_path)                    node.package = os.path.dirname(relative_path).replace(os.path.sep, '.')                    node.package = node.package if node.package else 'root'                                                package_parts = node.package.split('.')                current_package = unoplat_package_dict                full_package_name = \"\"                for i, part in enumerate(package_parts):                    full_package_name = part if i == 0 else f\"{full_package_name}.{part}\"                    if full_package_name not in current_package:                        current_package[full_package_name] = UnoplatPackage(name=full_package_name)                    if i == len(package_parts) - 1:                        current_package[full_package_name].nodes.append(node)                    else:                        current_package = current_package[full_package_name].sub_packages                                                    except Exception as e:                logger.error(f\"Error processing node: {e}\")        unoplat_codebase.packages =  unoplat_package_dict                return unoplat_codebase"},{"NodeName":"ISummariser","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/markdownparser/isummariser.py","MultipleExtend":["ABC"],"Functions":[{"Name":"summarise_to_markdown","Parameters":[{"TypeValue":"unoplat_codebase_summary","TypeType":"DspyUnoplatCodebaseSummary"}],"Annotations":[{"Name":"abstractmethod","Position":{"StartLine":10,"StartLinePosition":4,"StopLine":11,"StopLinePosition":4}}],"Position":{"StartLine":11,"StartLinePosition":4,"StopLine":21,"StopLinePosition":12},"Content":"def summarise_to_markdown(self, unoplat_codebase_summary: DspyUnoplatCodebaseSummary) -> str:        \"\"\"        Summarises the provided unoplat codebase summary to markdown.                Args:            unoplat_codebase_summary (DspyUnoplatCodebaseSummary): The unoplat codebase summary to summarise.                Returns:            str: The markdown string.        \"\"\"        pass"}],"Imports":[{"Source":"abc","UsageName":["ABC","abstractmethod"]},{"Source":"unoplat_code_confluence.data_models.dspy.dspy_unoplat_codebase_summary","UsageName":["DspyUnoplatCodebaseSummary"]}],"Position":{"StartLine":8,"StopLine":21,"StopLinePosition":12},"Content":"class ISummariser(ABC):        @abstractmethod    def summarise_to_markdown(self, unoplat_codebase_summary: DspyUnoplatCodebaseSummary) -> str:        \"\"\"        Summarises the provided unoplat codebase summary to markdown.                Args:            unoplat_codebase_summary (DspyUnoplatCodebaseSummary): The unoplat codebase summary to summarise.                Returns:            str: The markdown string.        \"\"\"        pass"},{"NodeName":"MarkdownSummariser","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/markdownparser/markdownsummariser.py","MultipleExtend":["ISummariser"],"Functions":[{"Name":"summarise_to_markdown","Parameters":[{"TypeValue":"unoplat_codebase_summary","TypeType":"DspyUnoplatCodebaseSummary"}],"FunctionCalls":[{"NodeName":"markdown_output","FunctionName":"append","Position":{"StartLine":61,"StartLinePosition":27,"StopLine":61,"StopLinePosition":39}}],"Position":{"StartLine":9,"StartLinePosition":4,"StopLine":63,"StopLinePosition":41},"LocalVariables":[{"TypeValue":"markdown_output","TypeType":"[]"}],"Content":"def summarise_to_markdown(self, unoplat_codebase_summary: DspyUnoplatCodebaseSummary) -> str:        markdown_output = []        # Codebase Summary        markdown_output.append(\"# Codebase Summary\\n\")        markdown_output.append(f\"**Name:** {unoplat_codebase_summary.codebase_name or 'N/A'}\\n\")        markdown_output.append(f\"**Objective:** {unoplat_codebase_summary.codebase_objective}\\n\")        markdown_output.append(f\"**Summary:** {unoplat_codebase_summary.codebase_summary}\\n\\n\")        # Package Summaries        markdown_output.append(\"## Package Summaries\\n\")        for package_name, package_summary in unoplat_codebase_summary.codebase_package.items():            markdown_output.append(f\"### {package_name}\\n\")            markdown_output.append(f\"**Objective:** {package_summary.package_objective}\\n\")            markdown_output.append(f\"**Summary:** {package_summary.package_summary}\\n\")                        if package_summary.class_summary:                markdown_output.append(\"#### Classes\\n\")                for class_detail in package_summary.class_summary:                    markdown_output.append(f\"##### {class_detail.node_name}\\n\")                    markdown_output.append(f\"**Objective:** {class_detail.node_objective}\\n\")                    if class_detail.node_summary:                        markdown_output.append(f\"**Summary:** {class_detail.node_summary}\\n\")                        if class_detail.functions_summary:                        markdown_output.append(\"**Functions:**\\n\")                        for function in class_detail.functions_summary:                            markdown_output.append(f\"- `{function.function_name}`\\n\")                            markdown_output.append(f\"  - Objective: {function.function_summary.objective}\\n\")                            markdown_output.append(f\"  - Implementation: {function.function_summary.implementation_summary.strip().replace('\\n', ' ')}\\n\")                    markdown_output.append(\"\\n\")            if package_summary.sub_package_summaries:                markdown_output.append(\"#### Sub-packages\\n\")                for sub_package_name,sub_package in package_summary.sub_package_summaries.items():                    markdown_output.append(f\"##### {sub_package_name}\\n\")                    markdown_output.append(f\"**Objective:** {sub_package.package_objective}\\n\")                    markdown_output.append(f\"**Summary:** {sub_package.package_summary}\\n\")                    if sub_package.class_summary:                        markdown_output.append(\"**Classes:**\\n\")                        for class_detail in sub_package.class_summary:                            markdown_output.append(f\"- {class_detail.node_name}\\n\")                            markdown_output.append(f\"  - Objective: {class_detail.node_objective}\\n\")                            if class_detail.functions_summary:                                markdown_output.append(\"  - Functions:\\n\")                                for function in class_detail.functions_summary:                                    markdown_output.append(f\"    - `{function.function_name}`\\n\")                                    markdown_output.append(f\"      - Objective: {function.function_summary.objective}\\n\")                                    markdown_output.append(f\"      - Implementation: {function.function_summary.implementation_summary.strip().replace('\\n', ' ')}\\n\")                    markdown_output.append(\"\\n\")            markdown_output.append(\"\\n\")        return \"\\n\".join(markdown_output)"}],"Imports":[{"Source":"unoplat_code_confluence.data_models.dspy.dspy_unoplat_codebase_summary","UsageName":["DspyUnoplatCodebaseSummary"]},{"Source":"unoplat_code_confluence.markdownparser.isummariser","UsageName":["ISummariser"]}],"Position":{"StartLine":8,"StopLine":63,"StopLinePosition":41},"Content":"class MarkdownSummariser(ISummariser):        def summarise_to_markdown(self, unoplat_codebase_summary: DspyUnoplatCodebaseSummary) -> str:        markdown_output = []        # Codebase Summary        markdown_output.append(\"# Codebase Summary\\n\")        markdown_output.append(f\"**Name:** {unoplat_codebase_summary.codebase_name or 'N/A'}\\n\")        markdown_output.append(f\"**Objective:** {unoplat_codebase_summary.codebase_objective}\\n\")        markdown_output.append(f\"**Summary:** {unoplat_codebase_summary.codebase_summary}\\n\\n\")        # Package Summaries        markdown_output.append(\"## Package Summaries\\n\")        for package_name, package_summary in unoplat_codebase_summary.codebase_package.items():            markdown_output.append(f\"### {package_name}\\n\")            markdown_output.append(f\"**Objective:** {package_summary.package_objective}\\n\")            markdown_output.append(f\"**Summary:** {package_summary.package_summary}\\n\")                        if package_summary.class_summary:                markdown_output.append(\"#### Classes\\n\")                for class_detail in package_summary.class_summary:                    markdown_output.append(f\"##### {class_detail.node_name}\\n\")                    markdown_output.append(f\"**Objective:** {class_detail.node_objective}\\n\")                    if class_detail.node_summary:                        markdown_output.append(f\"**Summary:** {class_detail.node_summary}\\n\")                        if class_detail.functions_summary:                        markdown_output.append(\"**Functions:**\\n\")                        for function in class_detail.functions_summary:                            markdown_output.append(f\"- `{function.function_name}`\\n\")                            markdown_output.append(f\"  - Objective: {function.function_summary.objective}\\n\")                            markdown_output.append(f\"  - Implementation: {function.function_summary.implementation_summary.strip().replace('\\n', ' ')}\\n\")                    markdown_output.append(\"\\n\")            if package_summary.sub_package_summaries:                markdown_output.append(\"#### Sub-packages\\n\")                for sub_package_name,sub_package in package_summary.sub_package_summaries.items():                    markdown_output.append(f\"##### {sub_package_name}\\n\")                    markdown_output.append(f\"**Objective:** {sub_package.package_objective}\\n\")                    markdown_output.append(f\"**Summary:** {sub_package.package_summary}\\n\")                    if sub_package.class_summary:                        markdown_output.append(\"**Classes:**\\n\")                        for class_detail in sub_package.class_summary:                            markdown_output.append(f\"- {class_detail.node_name}\\n\")                            markdown_output.append(f\"  - Objective: {class_detail.node_objective}\\n\")                            if class_detail.functions_summary:                                markdown_output.append(\"  - Functions:\\n\")                                for function in class_detail.functions_summary:                                    markdown_output.append(f\"    - `{function.function_name}`\\n\")                                    markdown_output.append(f\"      - Objective: {function.function_summary.objective}\\n\")                                    markdown_output.append(f\"      - Implementation: {function.function_summary.implementation_summary.strip().replace('\\n', ' ')}\\n\")                    markdown_output.append(\"\\n\")            markdown_output.append(\"\\n\")        return \"\\n\".join(markdown_output)"},{"NodeName":"CodebaseSummaryParser","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/summary_parser/codebase_summary.py","Functions":[{"Name":"__init__","Parameters":[{"TypeValue":"codebase","TypeType":"UnoplatCodebase"},{"TypeValue":"dspy_pipeline_function","TypeType":"CodeConfluenceFunctionModule"},{"TypeValue":"dspy_pipeline_class","TypeType":"CodeConfluenceClassModule"},{"TypeValue":"dspy_pipeline_package","TypeType":"CodeConfluencePackageModule"},{"TypeValue":"dspy_pipeline_codebase","TypeType":"CodeConfluenceCodebaseModule"},{"TypeValue":"app_config","TypeType":"AppConfig"}],"FunctionCalls":[{"NodeName":"app_config","FunctionName":"codebase_name","Position":{"StartLine":41,"StartLinePosition":39,"StopLine":41,"StopLinePosition":40}}],"Position":{"StartLine":32,"StartLinePosition":4,"StopLine":43,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"self.codebase","TypeType":"codebase"},{"TypeValue":"self.dspy_pipeline_function","TypeType":""},{"TypeValue":"self.dspy_pipeline_class","TypeType":""},{"TypeValue":"self.dspy_pipeline_package","TypeType":""},{"TypeValue":"self.dspy_pipeline_codebase","TypeType":""},{"TypeValue":"self.provider_list","TypeType":"self"},{"TypeValue":"self.json_output","TypeType":"app_config"},{"TypeValue":"self.codebase_name","TypeType":"app_config"}],"Content":"def __init__(self, codebase: UnoplatCodebase, dspy_pipeline_function: CodeConfluenceFunctionModule, dspy_pipeline_class: CodeConfluenceClassModule,dspy_pipeline_package: CodeConfluencePackageModule,dspy_pipeline_codebase: CodeConfluenceCodebaseModule,app_config: AppConfig):        self.codebase = codebase        self.dspy_pipeline_function: CodeConfluenceFunctionModule = dspy_pipeline_function        self.dspy_pipeline_class: CodeConfluenceClassModule = dspy_pipeline_class        self.dspy_pipeline_package: CodeConfluencePackageModule = dspy_pipeline_package        self.dspy_pipeline_codebase: CodeConfluenceCodebaseModule = dspy_pipeline_codebase        #TODO: we will be externalise the different llms that can be used at all dspy pipelines and within dspy pipelines once dspy switches to litellm        self.provider_list =self.init_dspy_lm(app_config.llm_provider_config,app_config.parallisation)        self.json_output = app_config.json_output        self.codebase_name = app_config.codebase_name    "},{"Name":"init_dspy_lm","Parameters":[{"TypeValue":"llm_config","TypeType":"dict"},{"TypeValue":"parallisation","TypeType":"int"}],"FunctionCalls":[{"NodeName":"self","FunctionName":"provider_list","Position":{"StartLine":58,"StartLinePosition":16,"StopLine":58,"StopLinePosition":17}},{"NodeName":"self","FunctionName":"extend","Position":{"StartLine":58,"StartLinePosition":30,"StopLine":63,"StopLinePosition":13}}],"Position":{"StartLine":43,"StartLinePosition":4,"StopLine":67,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"self.codebase","TypeType":"codebase"},{"TypeValue":"self.dspy_pipeline_function","TypeType":""},{"TypeValue":"self.dspy_pipeline_class","TypeType":""},{"TypeValue":"self.dspy_pipeline_package","TypeType":""},{"TypeValue":"self.dspy_pipeline_codebase","TypeType":""},{"TypeValue":"self.provider_list","TypeType":"[primary_provider]"},{"TypeValue":"self.json_output","TypeType":"app_config"},{"TypeValue":"self.codebase_name","TypeType":"app_config"},{"TypeValue":"primary_provider","TypeType":"dspy"}],"Content":"def init_dspy_lm(self, llm_config: dict, parallisation: int):        # Create the primary LLM provider using litellm configuration        primary_provider = dspy.LM(            model=llm_config[\"model_provider\"],            **llm_config[\"model_provider_args\"]        )                # Configure DSPy with the primary provider        dspy.configure(lm=primary_provider)                # Initialize the provider list with the primary provider        self.provider_list = [primary_provider]                # Add additional providers for parallelization if needed        if parallisation and parallisation > 1:            self.provider_list.extend([                dspy.LM(                    model=llm_config[\"model_provider\"],                    **llm_config[\"model_provider_args\"]                ) for _ in range(parallisation - 1)            ])                return self.provider_list                    "},{"Name":"parse_codebase","FunctionCalls":[{"NodeName":"f","FunctionName":"write","Position":{"StartLine":92,"StartLinePosition":17,"StopLine":92,"StopLinePosition":53}}],"Modifiers":["async"],"Position":{"StartLine":67,"StartLinePosition":4,"StopLine":98,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"self.codebase","TypeType":"codebase"},{"TypeValue":"self.dspy_pipeline_function","TypeType":""},{"TypeValue":"self.dspy_pipeline_class","TypeType":""},{"TypeValue":"self.dspy_pipeline_package","TypeType":""},{"TypeValue":"self.dspy_pipeline_codebase","TypeType":""},{"TypeValue":"self.provider_list","TypeType":"[primary_provider]"},{"TypeValue":"self.json_output","TypeType":"app_config"},{"TypeValue":"self.codebase_name","TypeType":"app_config"},{"TypeValue":"primary_provider","TypeType":"dspy"},{"TypeValue":"unoplat_codebase_summary","TypeType":"DspyUnoplatCodebaseSummary"},{"TypeValue":"root_packages","TypeType":""},{"TypeValue":"root_package_summaries","TypeType":""},{"TypeValue":"dspy_codebase_summary","TypeType":"self"},{"TypeValue":"unoplat_codebase_summary.codebase_summary","TypeType":"dspy_codebase_summary"},{"TypeValue":"unoplat_codebase_summary.codebase_objective","TypeType":"dspy_codebase_summary"},{"TypeValue":"unoplat_codebase_summary.codebase_package","TypeType":"root_package_summaries"},{"TypeValue":"json_unoplat_codebase_summary","TypeType":"unoplat_codebase_summary"},{"TypeValue":"current_timestamp","TypeType":"datetime"}],"Content":"async def parse_codebase(self) -> DspyUnoplatCodebaseSummary:                unoplat_codebase_summary = DspyUnoplatCodebaseSummary()                root_packages: Dict[str,UnoplatPackage] = self.codebase.packages        root_package_summaries = await self.process_packages(root_packages)        try:            dspy_codebase_summary = self.dspy_pipeline_codebase(package_objective_dict=root_package_summaries)        except Exception as e:            logger.error(f\"Error generating codebase summary: {e}\")            logger.exception(\"Traceback:\")            sys.exit(1)                    unoplat_codebase_summary.codebase_summary = dspy_codebase_summary.summary        unoplat_codebase_summary.codebase_objective = dspy_codebase_summary.answer        unoplat_codebase_summary.codebase_package = root_package_summaries        # if json_output is true, then write to a json file        if self.json_output:            json_unoplat_codebase_summary = unoplat_codebase_summary.model_dump_json()            # write to file            current_timestamp = datetime.datetime.now().strftime(\"%Y%m%d_%H%M%S\")            with open(f\"{self.codebase_name}_{current_timestamp}.json\", \"w\") as f:                f.write(json_unoplat_codebase_summary)        # write to md file        #todo: pydantic out to a file of unoplat codebase summary        return unoplat_codebase_summary    "},{"Name":"count_total_packages","Parameters":[{"TypeValue":"packages","TypeType":"Dict[str,UnoplatPackage]"}],"FunctionCalls":[{"NodeName":"stack","FunctionName":"extend","Position":{"StartLine":104,"StartLinePosition":17,"StopLine":104,"StopLinePosition":54}}],"Modifiers":["async"],"Position":{"StartLine":98,"StartLinePosition":4,"StopLine":107,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"self.codebase","TypeType":"codebase"},{"TypeValue":"self.dspy_pipeline_function","TypeType":""},{"TypeValue":"self.dspy_pipeline_class","TypeType":""},{"TypeValue":"self.dspy_pipeline_package","TypeType":""},{"TypeValue":"self.dspy_pipeline_codebase","TypeType":""},{"TypeValue":"self.provider_list","TypeType":"[primary_provider]"},{"TypeValue":"self.json_output","TypeType":"app_config"},{"TypeValue":"self.codebase_name","TypeType":"app_config"},{"TypeValue":"primary_provider","TypeType":"dspy"},{"TypeValue":"unoplat_codebase_summary","TypeType":"DspyUnoplatCodebaseSummary"},{"TypeValue":"root_packages","TypeType":""},{"TypeValue":"root_package_summaries","TypeType":""},{"TypeValue":"dspy_codebase_summary","TypeType":"self"},{"TypeValue":"unoplat_codebase_summary.codebase_summary","TypeType":"dspy_codebase_summary"},{"TypeValue":"unoplat_codebase_summary.codebase_objective","TypeType":"dspy_codebase_summary"},{"TypeValue":"unoplat_codebase_summary.codebase_package","TypeType":"root_package_summaries"},{"TypeValue":"json_unoplat_codebase_summary","TypeType":"unoplat_codebase_summary"},{"TypeValue":"current_timestamp","TypeType":"datetime"},{"TypeValue":"total","TypeType":""},{"TypeValue":"stack","TypeType":"list"},{"TypeValue":"package","TypeType":"stack"}],"Content":"async def count_total_packages(self, packages: Dict[str, UnoplatPackage]) -> int:        total = 0        stack = list(packages.values())        while stack:            package = stack.pop()            total += 1            stack.extend(package.sub_packages.values())        return total    "},{"Name":"process_packages","Parameters":[{"TypeValue":"packages","TypeType":"Dict[str,UnoplatPackage]"}],"FunctionCalls":[{"NodeName":"outer_prog","FunctionName":"update","Position":{"StartLine":181,"StartLinePosition":26,"StopLine":181,"StopLinePosition":35}}],"Modifiers":["async"],"Position":{"StartLine":107,"StartLinePosition":4,"StopLine":186,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"self.codebase","TypeType":"codebase"},{"TypeValue":"self.dspy_pipeline_function","TypeType":""},{"TypeValue":"self.dspy_pipeline_class","TypeType":""},{"TypeValue":"self.dspy_pipeline_package","TypeType":""},{"TypeValue":"self.dspy_pipeline_codebase","TypeType":""},{"TypeValue":"self.provider_list","TypeType":"[primary_provider]"},{"TypeValue":"self.json_output","TypeType":"app_config"},{"TypeValue":"self.codebase_name","TypeType":"app_config"},{"TypeValue":"primary_provider","TypeType":"dspy"},{"TypeValue":"unoplat_codebase_summary","TypeType":"DspyUnoplatCodebaseSummary"},{"TypeValue":"root_packages","TypeType":""},{"TypeValue":"root_package_summaries","TypeType":""},{"TypeValue":"dspy_codebase_summary","TypeType":"self"},{"TypeValue":"unoplat_codebase_summary.codebase_summary","TypeType":"dspy_codebase_summary"},{"TypeValue":"unoplat_codebase_summary.codebase_objective","TypeType":"dspy_codebase_summary"},{"TypeValue":"unoplat_codebase_summary.codebase_package","TypeType":"root_package_summaries"},{"TypeValue":"json_unoplat_codebase_summary","TypeType":"unoplat_codebase_summary"},{"TypeValue":"current_timestamp","TypeType":"datetime"},{"TypeValue":"total","TypeType":""},{"TypeValue":"stack","TypeType":"deque"},{"TypeValue":"package","TypeType":"stack"},{"TypeValue":"package_summaries","TypeType":""},{"TypeValue":"processed","TypeType":"set"},{"TypeValue":"memo","TypeType":"{}"},{"TypeValue":"total_packages","TypeType":""},{"TypeValue":"pman","TypeType":"ProgressManager"},{"TypeValue":"outer_prog","TypeType":"pman"},{"TypeValue":"","TypeType":"stack"},{"TypeValue":"sub_package_summaries","TypeType":""},{"TypeValue":"all_sub_packages_processed","TypeType":"False"},{"TypeValue":"package_summary","TypeType":"self"},{"TypeValue":"class_summaries","TypeType":""},{"TypeValue":"sub_package_summaries[sub_name]","TypeType":"memo"},{"TypeValue":"package_summary_object","TypeType":"DspyUnoplatPackageSummary"},{"TypeValue":"memo[package_name]","TypeType":"package_summary_object"},{"TypeValue":"package_summaries[package_name]","TypeType":"package_summary_object"}],"Content":"async def process_packages(self, packages: Dict[str,UnoplatPackage]) -> Dict[str,DspyUnoplatPackageSummary]:        package_summaries: Dict[str, DspyUnoplatPackageSummary] = {}        stack = deque([(name, package, True) for name, package in packages.items()])        processed = set()        memo = {}                total_packages = await self.count_total_packages(packages)                pman = ProgressManager(backend='rich')                with pman:            outer_prog = pman.progiter(range(total_packages), desc='Processing packages', verbose=2)            outer_prog.begin()            while stack:                package_name, package, is_root = stack.pop()                logger.debug(\"Current package popped from stack: {}\",package_name)                if package_name in processed:                    continue                                sub_package_summaries: Dict[str, DspyUnoplatPackageSummary] = {}                all_sub_packages_processed = True                for sub_name, sub_package in package.sub_packages.items():                                        if sub_name not in processed:                        stack.append((package_name, package, is_root))                        logger.debug(\"Adding current package {} to stack\",package_name)                        stack.append((sub_name, sub_package, False))                        logger.debug(\"Adding sub package {} to stack\",sub_name)                        all_sub_packages_processed = False                        break                if not all_sub_packages_processed:                    continue                # Process current package                if package_name in memo:                    package_summary = memo[package_name]                else:                    class_summaries = await self.process_classes_async(package.nodes,package_name,pman=pman,provider_list=self.provider_list)                    for sub_name in package.sub_packages:                        if sub_name in memo:                            logger.debug(\"Sub package {} already processed, adding to sub_package_summaries\",sub_name)                            sub_package_summaries[sub_name] = memo[sub_name]                    try:                        logger.debug(\"Generating package summary for {}\",package_name)                        package_summary =  self.dspy_pipeline_package(                            package_name=package_name,                            class_objective_list=class_summaries,                            sub_package_summaries=sub_package_summaries                        ).answer                        package_summary_object = DspyUnoplatPackageSummary(                            package_objective=package_summary.package_objective,                            package_summary=package_summary.package_summary,                            class_summary=class_summaries,                            sub_package_summaries=sub_package_summaries                        )                        memo[package_name] = package_summary_object                    except Exception as e:                        logger.error(f\"Error generating package summary for {package_name}: {e}\")                        logger.exception(\"Traceback:\")                        continue                if is_root:                    logger.debug(\"Adding root package {} to package_summaries\",package_name)                    package_summaries[package_name] = package_summary_object                                processed.add(package_name)                outer_prog.update(1)                        return package_summaries                "},{"Name":"process_batch","Parameters":[{"TypeValue":"batch","TypeType":"List[ChapiUnoplatNode]"},{"TypeValue":"package_name","TypeType":"str"},{"TypeValue":"pman","TypeType":"ProgressManager"},{"TypeValue":"lm_cycle","TypeType":"cycle"}],"FunctionCalls":[{"NodeName":"logger","FunctionName":"exception","Position":{"StartLine":197,"StartLinePosition":26,"StopLine":197,"StopLinePosition":49}}],"Modifiers":["async"],"Position":{"StartLine":186,"StartLinePosition":4,"StopLine":200,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"self.codebase","TypeType":"codebase"},{"TypeValue":"self.dspy_pipeline_function","TypeType":""},{"TypeValue":"self.dspy_pipeline_class","TypeType":""},{"TypeValue":"self.dspy_pipeline_package","TypeType":""},{"TypeValue":"self.dspy_pipeline_codebase","TypeType":""},{"TypeValue":"self.provider_list","TypeType":"[primary_provider]"},{"TypeValue":"self.json_output","TypeType":"app_config"},{"TypeValue":"self.codebase_name","TypeType":"app_config"},{"TypeValue":"primary_provider","TypeType":"dspy"},{"TypeValue":"unoplat_codebase_summary","TypeType":"DspyUnoplatCodebaseSummary"},{"TypeValue":"root_packages","TypeType":""},{"TypeValue":"root_package_summaries","TypeType":""},{"TypeValue":"dspy_codebase_summary","TypeType":"self"},{"TypeValue":"unoplat_codebase_summary.codebase_summary","TypeType":"dspy_codebase_summary"},{"TypeValue":"unoplat_codebase_summary.codebase_objective","TypeType":"dspy_codebase_summary"},{"TypeValue":"unoplat_codebase_summary.codebase_package","TypeType":"root_package_summaries"},{"TypeValue":"json_unoplat_codebase_summary","TypeType":"unoplat_codebase_summary"},{"TypeValue":"current_timestamp","TypeType":"datetime"},{"TypeValue":"total","TypeType":""},{"TypeValue":"stack","TypeType":"deque"},{"TypeValue":"package","TypeType":"stack"},{"TypeValue":"package_summaries","TypeType":""},{"TypeValue":"processed","TypeType":"set"},{"TypeValue":"memo","TypeType":"{}"},{"TypeValue":"total_packages","TypeType":""},{"TypeValue":"pman","TypeType":"ProgressManager"},{"TypeValue":"outer_prog","TypeType":"pman"},{"TypeValue":"","TypeType":"stack"},{"TypeValue":"sub_package_summaries","TypeType":""},{"TypeValue":"all_sub_packages_processed","TypeType":"False"},{"TypeValue":"package_summary","TypeType":"self"},{"TypeValue":"class_summaries","TypeType":""},{"TypeValue":"sub_package_summaries[sub_name]","TypeType":"memo"},{"TypeValue":"package_summary_object","TypeType":"DspyUnoplatPackageSummary"},{"TypeValue":"memo[package_name]","TypeType":"package_summary_object"},{"TypeValue":"package_summaries[package_name]","TypeType":"package_summary_object"},{"TypeValue":"tasks","TypeType":"[]"},{"TypeValue":"lm","TypeType":"next"},{"TypeValue":"task","TypeType":"tg"}],"Content":"async def process_batch(self, batch: List[ChapiUnoplatNode], package_name: str, pman: ProgressManager, lm_cycle: cycle) -> List[DspyUnoplatNodeSummary]:        tasks = []        async with asyncio.TaskGroup() as tg:            for node in batch:                                try:                    lm = next(lm_cycle)                    task = tg.create_task(self.process_single_class_wrapper(node, package_name, pman, lm))                    tasks.append(task)                except Exception as e:                    logger.error(f\"Error creating task for {node.node_name}: {e}\")                    logger.exception(\"Traceback:\")        return await self.collect_batch_results(tasks)    "},{"Name":"collect_batch_results","Parameters":[{"TypeValue":"tasks","TypeType":"List[asyncio.Task]"}],"FunctionCalls":[{"NodeName":"logger","FunctionName":"exception","Position":{"StartLine":209,"StartLinePosition":22,"StopLine":209,"StopLinePosition":45}}],"Modifiers":["async"],"Position":{"StartLine":200,"StartLinePosition":4,"StopLine":214,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"self.codebase","TypeType":"codebase"},{"TypeValue":"self.dspy_pipeline_function","TypeType":""},{"TypeValue":"self.dspy_pipeline_class","TypeType":""},{"TypeValue":"self.dspy_pipeline_package","TypeType":""},{"TypeValue":"self.dspy_pipeline_codebase","TypeType":""},{"TypeValue":"self.provider_list","TypeType":"[primary_provider]"},{"TypeValue":"self.json_output","TypeType":"app_config"},{"TypeValue":"self.codebase_name","TypeType":"app_config"},{"TypeValue":"primary_provider","TypeType":"dspy"},{"TypeValue":"unoplat_codebase_summary","TypeType":"DspyUnoplatCodebaseSummary"},{"TypeValue":"root_packages","TypeType":""},{"TypeValue":"root_package_summaries","TypeType":""},{"TypeValue":"dspy_codebase_summary","TypeType":"self"},{"TypeValue":"unoplat_codebase_summary.codebase_summary","TypeType":"dspy_codebase_summary"},{"TypeValue":"unoplat_codebase_summary.codebase_objective","TypeType":"dspy_codebase_summary"},{"TypeValue":"unoplat_codebase_summary.codebase_package","TypeType":"root_package_summaries"},{"TypeValue":"json_unoplat_codebase_summary","TypeType":"unoplat_codebase_summary"},{"TypeValue":"current_timestamp","TypeType":"datetime"},{"TypeValue":"total","TypeType":""},{"TypeValue":"stack","TypeType":"deque"},{"TypeValue":"package","TypeType":"stack"},{"TypeValue":"package_summaries","TypeType":""},{"TypeValue":"processed","TypeType":"set"},{"TypeValue":"memo","TypeType":"{}"},{"TypeValue":"total_packages","TypeType":""},{"TypeValue":"pman","TypeType":"ProgressManager"},{"TypeValue":"outer_prog","TypeType":"pman"},{"TypeValue":"","TypeType":"stack"},{"TypeValue":"sub_package_summaries","TypeType":""},{"TypeValue":"all_sub_packages_processed","TypeType":"False"},{"TypeValue":"package_summary","TypeType":"self"},{"TypeValue":"class_summaries","TypeType":""},{"TypeValue":"sub_package_summaries[sub_name]","TypeType":"memo"},{"TypeValue":"package_summary_object","TypeType":"DspyUnoplatPackageSummary"},{"TypeValue":"memo[package_name]","TypeType":"package_summary_object"},{"TypeValue":"package_summaries[package_name]","TypeType":"package_summary_object"},{"TypeValue":"tasks","TypeType":"[]"},{"TypeValue":"lm","TypeType":"next"},{"TypeValue":"task","TypeType":"tg"},{"TypeValue":"batch_results","TypeType":"[]"},{"TypeValue":"result","TypeType":""}],"Content":"async def collect_batch_results(self, tasks: List[asyncio.Task]) -> List[DspyUnoplatNodeSummary]:        batch_results = []        for task in tasks:            try:                result = await task                if result is not None:                    batch_results.append(result)            except Exception as e:                logger.error(f\"Error collecting batch result: {e}\")                logger.exception(\"Traceback:\")        return batch_results                    "},{"Name":"process_classes_async","Parameters":[{"TypeValue":"classes","TypeType":"List[ChapiUnoplatNode]"},{"TypeValue":"package_name","TypeType":"str"},{"TypeValue":"pman","TypeType":"ProgressManager"},{"TypeValue":"provider_list","TypeType":"List[dspy.LM]"}],"FunctionCalls":[{"NodeName":"class_summaries","FunctionName":"extend","Position":{"StartLine":222,"StartLinePosition":27,"StopLine":222,"StopLinePosition":50}}],"Modifiers":["async"],"Position":{"StartLine":214,"StartLinePosition":4,"StopLine":226,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"self.codebase","TypeType":"codebase"},{"TypeValue":"self.dspy_pipeline_function","TypeType":""},{"TypeValue":"self.dspy_pipeline_class","TypeType":""},{"TypeValue":"self.dspy_pipeline_package","TypeType":""},{"TypeValue":"self.dspy_pipeline_codebase","TypeType":""},{"TypeValue":"self.provider_list","TypeType":"[primary_provider]"},{"TypeValue":"self.json_output","TypeType":"app_config"},{"TypeValue":"self.codebase_name","TypeType":"app_config"},{"TypeValue":"primary_provider","TypeType":"dspy"},{"TypeValue":"unoplat_codebase_summary","TypeType":"DspyUnoplatCodebaseSummary"},{"TypeValue":"root_packages","TypeType":""},{"TypeValue":"root_package_summaries","TypeType":""},{"TypeValue":"dspy_codebase_summary","TypeType":"self"},{"TypeValue":"unoplat_codebase_summary.codebase_summary","TypeType":"dspy_codebase_summary"},{"TypeValue":"unoplat_codebase_summary.codebase_objective","TypeType":"dspy_codebase_summary"},{"TypeValue":"unoplat_codebase_summary.codebase_package","TypeType":"root_package_summaries"},{"TypeValue":"json_unoplat_codebase_summary","TypeType":"unoplat_codebase_summary"},{"TypeValue":"current_timestamp","TypeType":"datetime"},{"TypeValue":"total","TypeType":""},{"TypeValue":"stack","TypeType":"deque"},{"TypeValue":"package","TypeType":"stack"},{"TypeValue":"package_summaries","TypeType":""},{"TypeValue":"processed","TypeType":"set"},{"TypeValue":"memo","TypeType":"{}"},{"TypeValue":"total_packages","TypeType":""},{"TypeValue":"pman","TypeType":"ProgressManager"},{"TypeValue":"outer_prog","TypeType":"pman"},{"TypeValue":"","TypeType":"stack"},{"TypeValue":"sub_package_summaries","TypeType":""},{"TypeValue":"all_sub_packages_processed","TypeType":"False"},{"TypeValue":"package_summary","TypeType":"self"},{"TypeValue":"class_summaries","TypeType":"[]"},{"TypeValue":"sub_package_summaries[sub_name]","TypeType":"memo"},{"TypeValue":"package_summary_object","TypeType":"DspyUnoplatPackageSummary"},{"TypeValue":"memo[package_name]","TypeType":"package_summary_object"},{"TypeValue":"package_summaries[package_name]","TypeType":"package_summary_object"},{"TypeValue":"tasks","TypeType":"[]"},{"TypeValue":"lm","TypeType":"next"},{"TypeValue":"task","TypeType":"tg"},{"TypeValue":"batch_results","TypeType":"[]"},{"TypeValue":"result","TypeType":""},{"TypeValue":"concurrency","TypeType":"len"},{"TypeValue":"lm_cycle","TypeType":"cycle"},{"TypeValue":"batch","TypeType":"classes"},{"TypeValue":"batch_summaries","TypeType":""}],"Content":"async def process_classes_async(self, classes: List[ChapiUnoplatNode],package_name: str,pman: ProgressManager,provider_list: List[dspy.LM]) -> List[DspyUnoplatNodeSummary]:        class_summaries = []        concurrency = len(provider_list)        lm_cycle = cycle(provider_list)        for i in range(0, len(classes), concurrency):            batch = classes[i:i+concurrency]            batch_summaries = await self.process_batch(batch, package_name, pman, lm_cycle)            class_summaries.extend(batch_summaries)        return class_summaries        "},{"Name":"process_single_class_wrapper","Parameters":[{"TypeValue":"node","TypeType":"ChapiUnoplatNode"},{"TypeValue":"package_name","TypeType":"str"},{"TypeValue":"pman","TypeType":"ProgressManager"},{"TypeValue":"lm","TypeType":"dspy.LM"}],"Modifiers":["async"],"Position":{"StartLine":226,"StartLinePosition":4,"StopLine":230,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"self.codebase","TypeType":"codebase"},{"TypeValue":"self.dspy_pipeline_function","TypeType":""},{"TypeValue":"self.dspy_pipeline_class","TypeType":""},{"TypeValue":"self.dspy_pipeline_package","TypeType":""},{"TypeValue":"self.dspy_pipeline_codebase","TypeType":""},{"TypeValue":"self.provider_list","TypeType":"[primary_provider]"},{"TypeValue":"self.json_output","TypeType":"app_config"},{"TypeValue":"self.codebase_name","TypeType":"app_config"},{"TypeValue":"primary_provider","TypeType":"dspy"},{"TypeValue":"unoplat_codebase_summary","TypeType":"DspyUnoplatCodebaseSummary"},{"TypeValue":"root_packages","TypeType":""},{"TypeValue":"root_package_summaries","TypeType":""},{"TypeValue":"dspy_codebase_summary","TypeType":"self"},{"TypeValue":"unoplat_codebase_summary.codebase_summary","TypeType":"dspy_codebase_summary"},{"TypeValue":"unoplat_codebase_summary.codebase_objective","TypeType":"dspy_codebase_summary"},{"TypeValue":"unoplat_codebase_summary.codebase_package","TypeType":"root_package_summaries"},{"TypeValue":"json_unoplat_codebase_summary","TypeType":"unoplat_codebase_summary"},{"TypeValue":"current_timestamp","TypeType":"datetime"},{"TypeValue":"total","TypeType":""},{"TypeValue":"stack","TypeType":"deque"},{"TypeValue":"package","TypeType":"stack"},{"TypeValue":"package_summaries","TypeType":""},{"TypeValue":"processed","TypeType":"set"},{"TypeValue":"memo","TypeType":"{}"},{"TypeValue":"total_packages","TypeType":""},{"TypeValue":"pman","TypeType":"ProgressManager"},{"TypeValue":"outer_prog","TypeType":"pman"},{"TypeValue":"","TypeType":"stack"},{"TypeValue":"sub_package_summaries","TypeType":""},{"TypeValue":"all_sub_packages_processed","TypeType":"False"},{"TypeValue":"package_summary","TypeType":"self"},{"TypeValue":"class_summaries","TypeType":"[]"},{"TypeValue":"sub_package_summaries[sub_name]","TypeType":"memo"},{"TypeValue":"package_summary_object","TypeType":"DspyUnoplatPackageSummary"},{"TypeValue":"memo[package_name]","TypeType":"package_summary_object"},{"TypeValue":"package_summaries[package_name]","TypeType":"package_summary_object"},{"TypeValue":"tasks","TypeType":"[]"},{"TypeValue":"lm","TypeType":"next"},{"TypeValue":"task","TypeType":"tg"},{"TypeValue":"batch_results","TypeType":"[]"},{"TypeValue":"result","TypeType":""},{"TypeValue":"concurrency","TypeType":"len"},{"TypeValue":"lm_cycle","TypeType":"cycle"},{"TypeValue":"batch","TypeType":"classes"},{"TypeValue":"batch_summaries","TypeType":""}],"Content":"async def process_single_class_wrapper(self, node: ChapiUnoplatNode, package_name: str, pman: ProgressManager, lm: dspy.LM) -> DspyUnoplatNodeSummary:        return await asyncio.to_thread(self.process_single_class, node, package_name, pman, lm)        "},{"Name":"process_single_class","Parameters":[{"TypeValue":"node","TypeType":"ChapiUnoplatNode"},{"TypeValue":"package_name","TypeType":"str"},{"TypeValue":"pman","TypeType":"ProgressManager"},{"TypeValue":"lm","TypeType":"dspy.LM"}],"FunctionCalls":[{"NodeName":"logger","FunctionName":"exception","Position":{"StartLine":238,"StartLinePosition":18,"StopLine":238,"StopLinePosition":41}}],"Position":{"StartLine":230,"StartLinePosition":4,"StopLine":242,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"self.codebase","TypeType":"codebase"},{"TypeValue":"self.dspy_pipeline_function","TypeType":""},{"TypeValue":"self.dspy_pipeline_class","TypeType":""},{"TypeValue":"self.dspy_pipeline_package","TypeType":""},{"TypeValue":"self.dspy_pipeline_codebase","TypeType":""},{"TypeValue":"self.provider_list","TypeType":"[primary_provider]"},{"TypeValue":"self.json_output","TypeType":"app_config"},{"TypeValue":"self.codebase_name","TypeType":"app_config"},{"TypeValue":"primary_provider","TypeType":"dspy"},{"TypeValue":"unoplat_codebase_summary","TypeType":"DspyUnoplatCodebaseSummary"},{"TypeValue":"root_packages","TypeType":""},{"TypeValue":"root_package_summaries","TypeType":""},{"TypeValue":"dspy_codebase_summary","TypeType":"self"},{"TypeValue":"unoplat_codebase_summary.codebase_summary","TypeType":"dspy_codebase_summary"},{"TypeValue":"unoplat_codebase_summary.codebase_objective","TypeType":"dspy_codebase_summary"},{"TypeValue":"unoplat_codebase_summary.codebase_package","TypeType":"root_package_summaries"},{"TypeValue":"json_unoplat_codebase_summary","TypeType":"unoplat_codebase_summary"},{"TypeValue":"current_timestamp","TypeType":"datetime"},{"TypeValue":"total","TypeType":""},{"TypeValue":"stack","TypeType":"deque"},{"TypeValue":"package","TypeType":"stack"},{"TypeValue":"package_summaries","TypeType":""},{"TypeValue":"processed","TypeType":"set"},{"TypeValue":"memo","TypeType":"{}"},{"TypeValue":"total_packages","TypeType":""},{"TypeValue":"pman","TypeType":"ProgressManager"},{"TypeValue":"outer_prog","TypeType":"pman"},{"TypeValue":"","TypeType":"stack"},{"TypeValue":"sub_package_summaries","TypeType":""},{"TypeValue":"all_sub_packages_processed","TypeType":"False"},{"TypeValue":"package_summary","TypeType":"self"},{"TypeValue":"class_summaries","TypeType":"[]"},{"TypeValue":"sub_package_summaries[sub_name]","TypeType":"memo"},{"TypeValue":"package_summary_object","TypeType":"DspyUnoplatPackageSummary"},{"TypeValue":"memo[package_name]","TypeType":"package_summary_object"},{"TypeValue":"package_summaries[package_name]","TypeType":"package_summary_object"},{"TypeValue":"tasks","TypeType":"[]"},{"TypeValue":"lm","TypeType":"next"},{"TypeValue":"task","TypeType":"tg"},{"TypeValue":"batch_results","TypeType":"[]"},{"TypeValue":"result","TypeType":""},{"TypeValue":"concurrency","TypeType":"len"},{"TypeValue":"lm_cycle","TypeType":"cycle"},{"TypeValue":"batch","TypeType":"classes"},{"TypeValue":"batch_summaries","TypeType":""},{"TypeValue":"function_summaries","TypeType":"self"},{"TypeValue":"class_summary","TypeType":"self"}],"Content":"def process_single_class(self, node: ChapiUnoplatNode, package_name: str, pman: ProgressManager,  lm: dspy.LM) -> DspyUnoplatNodeSummary:        try:            with dspy.context(lm=lm):                function_summaries =  self.process_functions(node.functions, node, pman)                class_summary =  self.dspy_pipeline_class(class_metadata=node, function_objective_summary=function_summaries).answer                return class_summary        except Exception as e:            logger.error(f\"Error processing class {node.node_name}: {e}\")            logger.exception(\"Traceback:\")            return None    "},{"Name":"process_functions","Parameters":[{"TypeValue":"functions","TypeType":"List[ChapiUnoplatFunction]"},{"TypeValue":"node","TypeType":"ChapiUnoplatNode"},{"TypeValue":"pman","TypeType":"ProgressManager"}],"FunctionCalls":[{"NodeName":"logger","FunctionName":"exception","Position":{"StartLine":253,"StartLinePosition":26,"StopLine":253,"StopLinePosition":49}}],"Position":{"StartLine":242,"StartLinePosition":4,"StopLine":262,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"self.codebase","TypeType":"codebase"},{"TypeValue":"self.dspy_pipeline_function","TypeType":""},{"TypeValue":"self.dspy_pipeline_class","TypeType":""},{"TypeValue":"self.dspy_pipeline_package","TypeType":""},{"TypeValue":"self.dspy_pipeline_codebase","TypeType":""},{"TypeValue":"self.provider_list","TypeType":"[primary_provider]"},{"TypeValue":"self.json_output","TypeType":"app_config"},{"TypeValue":"self.codebase_name","TypeType":"app_config"},{"TypeValue":"primary_provider","TypeType":"dspy"},{"TypeValue":"unoplat_codebase_summary","TypeType":"DspyUnoplatCodebaseSummary"},{"TypeValue":"root_packages","TypeType":""},{"TypeValue":"root_package_summaries","TypeType":""},{"TypeValue":"dspy_codebase_summary","TypeType":"self"},{"TypeValue":"unoplat_codebase_summary.codebase_summary","TypeType":"dspy_codebase_summary"},{"TypeValue":"unoplat_codebase_summary.codebase_objective","TypeType":"dspy_codebase_summary"},{"TypeValue":"unoplat_codebase_summary.codebase_package","TypeType":"root_package_summaries"},{"TypeValue":"json_unoplat_codebase_summary","TypeType":"unoplat_codebase_summary"},{"TypeValue":"current_timestamp","TypeType":"datetime"},{"TypeValue":"total","TypeType":""},{"TypeValue":"stack","TypeType":"deque"},{"TypeValue":"package","TypeType":"stack"},{"TypeValue":"package_summaries","TypeType":""},{"TypeValue":"processed","TypeType":"set"},{"TypeValue":"memo","TypeType":"{}"},{"TypeValue":"total_packages","TypeType":""},{"TypeValue":"pman","TypeType":"ProgressManager"},{"TypeValue":"outer_prog","TypeType":"pman"},{"TypeValue":"","TypeType":"stack"},{"TypeValue":"sub_package_summaries","TypeType":""},{"TypeValue":"all_sub_packages_processed","TypeType":"False"},{"TypeValue":"package_summary","TypeType":"self"},{"TypeValue":"class_summaries","TypeType":"[]"},{"TypeValue":"sub_package_summaries[sub_name]","TypeType":"memo"},{"TypeValue":"package_summary_object","TypeType":"DspyUnoplatPackageSummary"},{"TypeValue":"memo[package_name]","TypeType":"package_summary_object"},{"TypeValue":"package_summaries[package_name]","TypeType":"package_summary_object"},{"TypeValue":"tasks","TypeType":"[]"},{"TypeValue":"lm","TypeType":"next"},{"TypeValue":"task","TypeType":"tg"},{"TypeValue":"batch_results","TypeType":"[]"},{"TypeValue":"result","TypeType":""},{"TypeValue":"concurrency","TypeType":"len"},{"TypeValue":"lm_cycle","TypeType":"cycle"},{"TypeValue":"batch","TypeType":"classes"},{"TypeValue":"batch_summaries","TypeType":""},{"TypeValue":"function_summaries","TypeType":"[]"},{"TypeValue":"class_summary","TypeType":"self"},{"TypeValue":"dspy_function_result","TypeType":"self"},{"TypeValue":"function_objective","TypeType":"dspy_function_result"},{"TypeValue":"function_summary","TypeType":"dspy_function_result"}],"Content":"def process_functions(self, functions: List[ChapiUnoplatFunction], node: ChapiUnoplatNode, pman: ProgressManager) -> List[DspyUnoplatFunctionSummary]:        function_summaries = []        for function in functions:            if function.name:                try:                    dspy_function_result =  self.dspy_pipeline_function(function_metadata=function, class_metadata=node)                    function_objective = dspy_function_result.objective                    function_summary = dspy_function_result.implementation_summary                    function_summaries.append(DspyUnoplatFunctionSummary(function_name=function.name, objective=function_objective, implementation_summary=function_summary))                except Exception as e:                    logger.error(f\"Error generating function summary for {function.name}: {e}\")                    logger.exception(\"Traceback:\")        return function_summaries                                          "}],"Imports":[{"Source":"asyncio"},{"Source":"datetime"},{"Source":"sys"},{"Source":"collections","UsageName":["deque"]},{"Source":"itertools","UsageName":["cycle"]},{"Source":"typing","UsageName":["Dict","List"]},{"Source":"dspy"},{"Source":"loguru","UsageName":["logger"]},{"Source":"progiter.manager","UsageName":["ProgressManager"]},{"Source":"unoplat_code_confluence.configuration.external_config","UsageName":["AppConfig"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_codebase","UsageName":["UnoplatCodebase"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_function","UsageName":["ChapiUnoplatFunction"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_node","UsageName":["ChapiUnoplatNode"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_package","UsageName":["UnoplatPackage"]},{"Source":"unoplat_code_confluence.data_models.dspy.dspy_unoplat_codebase_summary","UsageName":["DspyUnoplatCodebaseSummary"]},{"Source":"unoplat_code_confluence.data_models.dspy.dspy_unoplat_function_summary","UsageName":["DspyUnoplatFunctionSummary"]},{"Source":"unoplat_code_confluence.data_models.dspy.dspy_unoplat_node_summary","UsageName":["DspyUnoplatNodeSummary"]},{"Source":"unoplat_code_confluence.data_models.dspy.dspy_unoplat_package_summary","UsageName":["DspyUnoplatPackageSummary"]},{"Source":"unoplat_code_confluence.dspy_class_summary","UsageName":["CodeConfluenceClassModule"]},{"Source":"unoplat_code_confluence.dspy_codebase_summary","UsageName":["CodeConfluenceCodebaseModule"]},{"Source":"unoplat_code_confluence.dspy_function_summary","UsageName":["CodeConfluenceFunctionModule"]},{"Source":"unoplat_code_confluence.dspy_package_summary","UsageName":["CodeConfluencePackageModule"]}],"Position":{"StartLine":30,"StopLine":262,"StopLinePosition":4},"Content":"class CodebaseSummaryParser:        def __init__(self, codebase: UnoplatCodebase, dspy_pipeline_function: CodeConfluenceFunctionModule, dspy_pipeline_class: CodeConfluenceClassModule,dspy_pipeline_package: CodeConfluencePackageModule,dspy_pipeline_codebase: CodeConfluenceCodebaseModule,app_config: AppConfig):        self.codebase = codebase        self.dspy_pipeline_function: CodeConfluenceFunctionModule = dspy_pipeline_function        self.dspy_pipeline_class: CodeConfluenceClassModule = dspy_pipeline_class        self.dspy_pipeline_package: CodeConfluencePackageModule = dspy_pipeline_package        self.dspy_pipeline_codebase: CodeConfluenceCodebaseModule = dspy_pipeline_codebase        #TODO: we will be externalise the different llms that can be used at all dspy pipelines and within dspy pipelines once dspy switches to litellm        self.provider_list =self.init_dspy_lm(app_config.llm_provider_config,app_config.parallisation)        self.json_output = app_config.json_output        self.codebase_name = app_config.codebase_name    def init_dspy_lm(self, llm_config: dict, parallisation: int):        # Create the primary LLM provider using litellm configuration        primary_provider = dspy.LM(            model=llm_config[\"model_provider\"],            **llm_config[\"model_provider_args\"]        )                # Configure DSPy with the primary provider        dspy.configure(lm=primary_provider)                # Initialize the provider list with the primary provider        self.provider_list = [primary_provider]                # Add additional providers for parallelization if needed        if parallisation and parallisation > 1:            self.provider_list.extend([                dspy.LM(                    model=llm_config[\"model_provider\"],                    **llm_config[\"model_provider_args\"]                ) for _ in range(parallisation - 1)            ])                return self.provider_list                    async def parse_codebase(self) -> DspyUnoplatCodebaseSummary:                unoplat_codebase_summary = DspyUnoplatCodebaseSummary()                root_packages: Dict[str,UnoplatPackage] = self.codebase.packages        root_package_summaries = await self.process_packages(root_packages)        try:            dspy_codebase_summary = self.dspy_pipeline_codebase(package_objective_dict=root_package_summaries)        except Exception as e:            logger.error(f\"Error generating codebase summary: {e}\")            logger.exception(\"Traceback:\")            sys.exit(1)                    unoplat_codebase_summary.codebase_summary = dspy_codebase_summary.summary        unoplat_codebase_summary.codebase_objective = dspy_codebase_summary.answer        unoplat_codebase_summary.codebase_package = root_package_summaries        # if json_output is true, then write to a json file        if self.json_output:            json_unoplat_codebase_summary = unoplat_codebase_summary.model_dump_json()            # write to file            current_timestamp = datetime.datetime.now().strftime(\"%Y%m%d_%H%M%S\")            with open(f\"{self.codebase_name}_{current_timestamp}.json\", \"w\") as f:                f.write(json_unoplat_codebase_summary)        # write to md file        #todo: pydantic out to a file of unoplat codebase summary        return unoplat_codebase_summary    async def count_total_packages(self, packages: Dict[str, UnoplatPackage]) -> int:        total = 0        stack = list(packages.values())        while stack:            package = stack.pop()            total += 1            stack.extend(package.sub_packages.values())        return total    async def process_packages(self, packages: Dict[str,UnoplatPackage]) -> Dict[str,DspyUnoplatPackageSummary]:        package_summaries: Dict[str, DspyUnoplatPackageSummary] = {}        stack = deque([(name, package, True) for name, package in packages.items()])        processed = set()        memo = {}                total_packages = await self.count_total_packages(packages)                pman = ProgressManager(backend='rich')                with pman:            outer_prog = pman.progiter(range(total_packages), desc='Processing packages', verbose=2)            outer_prog.begin()            while stack:                package_name, package, is_root = stack.pop()                logger.debug(\"Current package popped from stack: {}\",package_name)                if package_name in processed:                    continue                                sub_package_summaries: Dict[str, DspyUnoplatPackageSummary] = {}                all_sub_packages_processed = True                for sub_name, sub_package in package.sub_packages.items():                                        if sub_name not in processed:                        stack.append((package_name, package, is_root))                        logger.debug(\"Adding current package {} to stack\",package_name)                        stack.append((sub_name, sub_package, False))                        logger.debug(\"Adding sub package {} to stack\",sub_name)                        all_sub_packages_processed = False                        break                if not all_sub_packages_processed:                    continue                # Process current package                if package_name in memo:                    package_summary = memo[package_name]                else:                    class_summaries = await self.process_classes_async(package.nodes,package_name,pman=pman,provider_list=self.provider_list)                    for sub_name in package.sub_packages:                        if sub_name in memo:                            logger.debug(\"Sub package {} already processed, adding to sub_package_summaries\",sub_name)                            sub_package_summaries[sub_name] = memo[sub_name]                    try:                        logger.debug(\"Generating package summary for {}\",package_name)                        package_summary =  self.dspy_pipeline_package(                            package_name=package_name,                            class_objective_list=class_summaries,                            sub_package_summaries=sub_package_summaries                        ).answer                        package_summary_object = DspyUnoplatPackageSummary(                            package_objective=package_summary.package_objective,                            package_summary=package_summary.package_summary,                            class_summary=class_summaries,                            sub_package_summaries=sub_package_summaries                        )                        memo[package_name] = package_summary_object                    except Exception as e:                        logger.error(f\"Error generating package summary for {package_name}: {e}\")                        logger.exception(\"Traceback:\")                        continue                if is_root:                    logger.debug(\"Adding root package {} to package_summaries\",package_name)                    package_summaries[package_name] = package_summary_object                                processed.add(package_name)                outer_prog.update(1)                        return package_summaries                async def process_batch(self, batch: List[ChapiUnoplatNode], package_name: str, pman: ProgressManager, lm_cycle: cycle) -> List[DspyUnoplatNodeSummary]:        tasks = []        async with asyncio.TaskGroup() as tg:            for node in batch:                                try:                    lm = next(lm_cycle)                    task = tg.create_task(self.process_single_class_wrapper(node, package_name, pman, lm))                    tasks.append(task)                except Exception as e:                    logger.error(f\"Error creating task for {node.node_name}: {e}\")                    logger.exception(\"Traceback:\")        return await self.collect_batch_results(tasks)    async def collect_batch_results(self, tasks: List[asyncio.Task]) -> List[DspyUnoplatNodeSummary]:        batch_results = []        for task in tasks:            try:                result = await task                if result is not None:                    batch_results.append(result)            except Exception as e:                logger.error(f\"Error collecting batch result: {e}\")                logger.exception(\"Traceback:\")        return batch_results                    async def process_classes_async(self, classes: List[ChapiUnoplatNode],package_name: str,pman: ProgressManager,provider_list: List[dspy.LM]) -> List[DspyUnoplatNodeSummary]:        class_summaries = []        concurrency = len(provider_list)        lm_cycle = cycle(provider_list)        for i in range(0, len(classes), concurrency):            batch = classes[i:i+concurrency]            batch_summaries = await self.process_batch(batch, package_name, pman, lm_cycle)            class_summaries.extend(batch_summaries)        return class_summaries        async def process_single_class_wrapper(self, node: ChapiUnoplatNode, package_name: str, pman: ProgressManager, lm: dspy.LM) -> DspyUnoplatNodeSummary:        return await asyncio.to_thread(self.process_single_class, node, package_name, pman, lm)        def process_single_class(self, node: ChapiUnoplatNode, package_name: str, pman: ProgressManager,  lm: dspy.LM) -> DspyUnoplatNodeSummary:        try:            with dspy.context(lm=lm):                function_summaries =  self.process_functions(node.functions, node, pman)                class_summary =  self.dspy_pipeline_class(class_metadata=node, function_objective_summary=function_summaries).answer                return class_summary        except Exception as e:            logger.error(f\"Error processing class {node.node_name}: {e}\")            logger.exception(\"Traceback:\")            return None    def process_functions(self, functions: List[ChapiUnoplatFunction], node: ChapiUnoplatNode, pman: ProgressManager) -> List[DspyUnoplatFunctionSummary]:        function_summaries = []        for function in functions:            if function.name:                try:                    dspy_function_result =  self.dspy_pipeline_function(function_metadata=function, class_metadata=node)                    function_objective = dspy_function_result.objective                    function_summary = dspy_function_result.implementation_summary                    function_summaries.append(DspyUnoplatFunctionSummary(function_name=function.name, objective=function_objective, implementation_summary=function_summary))                except Exception as e:                    logger.error(f\"Error generating function summary for {function.name}: {e}\")                    logger.exception(\"Traceback:\")        return function_summaries                                          "},{"NodeName":"default","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/__main__.py","Functions":[{"Name":"start_pipeline","FunctionCalls":[{"NodeName":"iload_json","FunctionName":"load_json_from_file","Position":{"StartLine":38,"StartLinePosition":40,"StopLine":38,"StopLinePosition":72}}],"Modifiers":["async"],"Position":{"StartLine":27,"StopLine":48},"LocalVariables":[{"TypeValue":"parser","TypeType":"argparse"},{"TypeValue":"args","TypeType":"parser"},{"TypeValue":"iload_json","TypeType":"JsonLoader"},{"TypeValue":"iparse_json","TypeType":"JsonParser"},{"TypeValue":"isummariser","TypeType":"MarkdownSummariser"},{"TypeValue":"json_configuration_data","TypeType":"iload_json"}],"Content":"async def start_pipeline():    # Standard Library    import os    parser = argparse.ArgumentParser(description=\"Codebase Parser CLI\")    parser.add_argument(\"--config\", help=\"Path to configuration file for unoplat utility\", default=os.getcwd() + '/default_config.json', type=str)    args = parser.parse_args()    iload_json = JsonLoader()    iparse_json = JsonParser()    isummariser = MarkdownSummariser()    #loading the config    json_configuration_data = iload_json.load_json_from_file(args.config)        #TODO: fix logging config    # logging_config = iload_json.load_json_from_file(\"loguru.json\")    # logger.configure(handlers=logging_config[\"handlers\"])    await get_codebase_metadata(json_configuration_data,iload_json,iparse_json,isummariser)    "},{"Name":"get_codebase_metadata","Parameters":[{"TypeValue":"json_configuration_data","TypeType":""},{"TypeValue":"iload_json","TypeType":""},{"TypeValue":"iparse_json","TypeType":""},{"TypeValue":"isummariser","TypeType":""}],"FunctionCalls":[{"NodeName":"logger","FunctionName":"configure","Position":{"StartLine":51,"StartLinePosition":10,"StopLine":51,"StopLinePosition":49}}],"Modifiers":["async"],"Position":{"StartLine":48,"StopLine":63},"LocalVariables":[{"TypeValue":"parser","TypeType":"argparse"},{"TypeValue":"args","TypeType":"parser"},{"TypeValue":"iload_json","TypeType":"JsonLoader"},{"TypeValue":"iparse_json","TypeType":"JsonParser"},{"TypeValue":"isummariser","TypeType":"MarkdownSummariser"},{"TypeValue":"json_configuration_data","TypeType":"iload_json"},{"TypeValue":"app_config","TypeType":"AppConfig"}],"Content":"async def get_codebase_metadata(json_configuration_data,iload_json,iparse_json,isummariser):    # Collect necessary inputs from the user to set up the codebase indexing    app_config = AppConfig(**json_configuration_data)    logger.configure(handlers=app_config.handlers)    # Button to submit the indexing    await start_parsing(        app_config,        iload_json,        iparse_json,        isummariser    )"},{"Name":"ensure_jar_downloaded","Parameters":[{"TypeValue":"github_token","TypeType":""},{"TypeValue":"arcguard_cli_repo","TypeType":""},{"TypeValue":"local_download_directory","TypeType":""}],"FunctionCalls":[{"NodeName":"Downloader","FunctionName":"download_latest_jar","Position":{"StartLine":65,"StartLinePosition":25,"StopLine":65,"StopLinePosition":103}}],"Modifiers":["async"],"Position":{"StartLine":63,"StopLine":69},"LocalVariables":[{"TypeValue":"parser","TypeType":"argparse"},{"TypeValue":"args","TypeType":"parser"},{"TypeValue":"iload_json","TypeType":"JsonLoader"},{"TypeValue":"iparse_json","TypeType":"JsonParser"},{"TypeValue":"isummariser","TypeType":"MarkdownSummariser"},{"TypeValue":"json_configuration_data","TypeType":"iload_json"},{"TypeValue":"app_config","TypeType":"AppConfig"},{"TypeValue":"jar_path","TypeType":"Downloader"}],"Content":"async def ensure_jar_downloaded(github_token, arcguard_cli_repo, local_download_directory):        jar_path = Downloader.download_latest_jar(arcguard_cli_repo, local_download_directory, github_token)        return jar_path"},{"Name":"get_extension","Parameters":[{"TypeValue":"programming_language","TypeType":"str"}],"Modifiers":["async"],"Position":{"StartLine":69,"StopLine":78},"LocalVariables":[{"TypeValue":"parser","TypeType":"argparse"},{"TypeValue":"args","TypeType":"parser"},{"TypeValue":"iload_json","TypeType":"JsonLoader"},{"TypeValue":"iparse_json","TypeType":"JsonParser"},{"TypeValue":"isummariser","TypeType":"MarkdownSummariser"},{"TypeValue":"json_configuration_data","TypeType":"iload_json"},{"TypeValue":"app_config","TypeType":"AppConfig"},{"TypeValue":"jar_path","TypeType":"Downloader"}],"Content":"async def get_extension(programming_language: str):    #TODO: convert this to enum based check    if programming_language == \"java\":        return \"java\"    elif programming_language == \"python\":        return \"py\"    else:        raise ValueError(f\"Unsupported programming language: {programming_language}\")"},{"Name":"start_parsing","Parameters":[{"TypeValue":"app_config","TypeType":"AppConfig"},{"TypeValue":"iload_json","TypeType":"JsonLoader"},{"TypeValue":"iparse_json","TypeType":"JsonParser"},{"TypeValue":"isummariser","TypeType":"MarkdownSummariser"}],"FunctionCalls":[{"NodeName":"logger","FunctionName":"info","Position":{"StartLine":141,"StartLinePosition":10,"StopLine":141,"StopLinePosition":44}}],"Modifiers":["async"],"Position":{"StartLine":78,"StopLine":144},"LocalVariables":[{"TypeValue":"parser","TypeType":"argparse"},{"TypeValue":"args","TypeType":"parser"},{"TypeValue":"iload_json","TypeType":"JsonLoader"},{"TypeValue":"iparse_json","TypeType":"JsonParser"},{"TypeValue":"isummariser","TypeType":"MarkdownSummariser"},{"TypeValue":"json_configuration_data","TypeType":"iload_json"},{"TypeValue":"app_config","TypeType":"AppConfig"},{"TypeValue":"jar_path","TypeType":""},{"TypeValue":"extension","TypeType":""},{"TypeValue":"archguard_handler","TypeType":"ArchGuardHandler"},{"TypeValue":"chapi_metadata_path","TypeType":"archguard_handler"},{"TypeValue":"chapi_metadata","TypeType":"iload_json"},{"TypeValue":"current_timestamp","TypeType":"datetime"},{"TypeValue":"output_filename","TypeType":"f\"{app_config.codebase_name}_{current_timestamp}.md\""},{"TypeValue":"unoplat_codebase","TypeType":""},{"TypeValue":"dspy_function_pipeline_summary","TypeType":""},{"TypeValue":"dspy_class_pipeline_summary","TypeType":""},{"TypeValue":"dspy_package_pipeline_summary","TypeType":""},{"TypeValue":"dspy_codebase_pipeline_summary","TypeType":""},{"TypeValue":"codebase_summary","TypeType":"CodebaseSummaryParser"},{"TypeValue":"unoplat_codebase_summary","TypeType":""},{"TypeValue":"unoplat_graph_processing","TypeType":"UnoplatGraphProcessing"},{"TypeValue":"unoplat_codebase_summary.codebase_name","TypeType":"app_config"},{"TypeValue":"markdown_output","TypeType":"isummariser"}],"Content":"async def start_parsing(app_config: AppConfig, iload_json: JsonLoader, iparse_json: JsonParser, isummariser: MarkdownSummariser):    # Log the start of the parsing process    logger.info(\"Starting parsing process...\")        # Ensure the JAR is downloaded or use the existing one    jar_path = await ensure_jar_downloaded(app_config.api_tokens[\"github_token\"],app_config.repo.download_url,app_config.repo.download_directory)    logger.info(f\"Local Workspace URL: {app_config.local_workspace_path}\")    logger.info(f\"Programming Language: {app_config.programming_language}\")    logger.info(f\"Output Path: {app_config.output_path}\")    logger.info(f\"Codebase Name: {app_config.codebase_name}\")        # based on programming_language convert to extension    extension = await get_extension(app_config.programming_language)    # Initialize the ArchGuard handler with the collected parameters.    archguard_handler = ArchGuardHandler(        jar_path=jar_path,        language=app_config.programming_language,        codebase_path=app_config.local_workspace_path,        codebase_name=app_config.codebase_name,        output_path=app_config.output_path,        extension=extension    )        chapi_metadata_path = archguard_handler.run_scan()    chapi_metadata = iload_json.load_json_from_file(chapi_metadata_path)          current_timestamp = datetime.datetime.now().strftime(\"%Y%m%d%H%M%S\")        output_filename = f\"{app_config.codebase_name}_{current_timestamp}.md\"    unoplat_codebase : UnoplatCodebase = iparse_json.parse_json_to_nodes(chapi_metadata,app_config.local_workspace_path,app_config.programming_language)        dspy_function_pipeline_summary : CodeConfluenceFunctionModule = CodeConfluenceFunctionModule()        dspy_class_pipeline_summary : CodeConfluenceClassModule = CodeConfluenceClassModule()        dspy_package_pipeline_summary : CodeConfluencePackageModule = CodeConfluencePackageModule()    dspy_codebase_pipeline_summary: CodeConfluenceCodebaseModule = CodeConfluenceCodebaseModule()    dspy_function_pipeline_summary : CodeConfluenceFunctionModule = CodeConfluenceFunctionModule()        dspy_class_pipeline_summary : CodeConfluenceClassModule = CodeConfluenceClassModule()    codebase_summary = CodebaseSummaryParser(unoplat_codebase,dspy_function_pipeline_summary, dspy_class_pipeline_summary,dspy_package_pipeline_summary,dspy_codebase_pipeline_summary,app_config)    unoplat_codebase_summary: DspyUnoplatCodebaseSummary = await codebase_summary.parse_codebase()        unoplat_graph_processing = UnoplatGraphProcessing(app_config)    unoplat_codebase_summary.codebase_name = app_config.codebase_name        unoplat_graph_processing.process_codebase_summary(unoplat_codebase,unoplat_codebase_summary)    markdown_output = isummariser.summarise_to_markdown(unoplat_codebase_summary)    # write the markdown output to a file    with open(os.path.join(app_config.output_path, output_filename), 'w') as md_file:        md_file.write(markdown_output)            logger.info(\"Parsing process completed.\")    "},{"Name":"main","FunctionCalls":[{"NodeName":"asyncio","FunctionName":"run","Position":{"StartLine":146,"StartLinePosition":11,"StopLine":146,"StopLinePosition":32}}],"Position":{"StartLine":144,"StopLine":148},"LocalVariables":[{"TypeValue":"parser","TypeType":"argparse"},{"TypeValue":"args","TypeType":"parser"},{"TypeValue":"iload_json","TypeType":"JsonLoader"},{"TypeValue":"iparse_json","TypeType":"JsonParser"},{"TypeValue":"isummariser","TypeType":"MarkdownSummariser"},{"TypeValue":"json_configuration_data","TypeType":"iload_json"},{"TypeValue":"app_config","TypeType":"AppConfig"},{"TypeValue":"jar_path","TypeType":""},{"TypeValue":"extension","TypeType":""},{"TypeValue":"archguard_handler","TypeType":"ArchGuardHandler"},{"TypeValue":"chapi_metadata_path","TypeType":"archguard_handler"},{"TypeValue":"chapi_metadata","TypeType":"iload_json"},{"TypeValue":"current_timestamp","TypeType":"datetime"},{"TypeValue":"output_filename","TypeType":"f\"{app_config.codebase_name}_{current_timestamp}.md\""},{"TypeValue":"unoplat_codebase","TypeType":""},{"TypeValue":"dspy_function_pipeline_summary","TypeType":""},{"TypeValue":"dspy_class_pipeline_summary","TypeType":""},{"TypeValue":"dspy_package_pipeline_summary","TypeType":""},{"TypeValue":"dspy_codebase_pipeline_summary","TypeType":""},{"TypeValue":"codebase_summary","TypeType":"CodebaseSummaryParser"},{"TypeValue":"unoplat_codebase_summary","TypeType":""},{"TypeValue":"unoplat_graph_processing","TypeType":"UnoplatGraphProcessing"},{"TypeValue":"unoplat_codebase_summary.codebase_name","TypeType":"app_config"},{"TypeValue":"markdown_output","TypeType":"isummariser"}],"Content":"def main():    warnings.filterwarnings(\"ignore\", category=DeprecationWarning, module='pydantic.*')    asyncio.run(start_pipeline())"}],"Imports":[{"Source":"argparse"},{"Source":"asyncio"},{"Source":"datetime"},{"Source":"warnings"},{"Source":"loguru","UsageName":["logger"]},{"Source":"unoplat_code_confluence.codebaseparser.arc_guard_handler","UsageName":["ArchGuardHandler"]},{"Source":"unoplat_code_confluence.configuration.external_config","UsageName":["AppConfig"]},{"Source":"unoplat_code_confluence.data_models.chapi_unoplat_codebase","UsageName":["UnoplatCodebase"]},{"Source":"unoplat_code_confluence.data_models.dspy.dspy_unoplat_codebase_summary","UsageName":["DspyUnoplatCodebaseSummary"]},{"Source":"unoplat_code_confluence.database.graph.unoplat_graph_processing","UsageName":["UnoplatGraphProcessing"]},{"Source":"unoplat_code_confluence.downloader.downloader","UsageName":["Downloader"]},{"Source":"unoplat_code_confluence.dspy_class_summary","UsageName":["CodeConfluenceClassModule"]},{"Source":"unoplat_code_confluence.dspy_codebase_summary","UsageName":["CodeConfluenceCodebaseModule"]},{"Source":"unoplat_code_confluence.dspy_function_summary","UsageName":["CodeConfluenceFunctionModule"]},{"Source":"unoplat_code_confluence.dspy_package_summary","UsageName":["CodeConfluencePackageModule"]},{"Source":"unoplat_code_confluence.loader.json_loader","UsageName":["JsonLoader"]},{"Source":"unoplat_code_confluence.loader.parse_json","UsageName":["JsonParser"]},{"Source":"unoplat_code_confluence.markdownparser.markdownsummariser","UsageName":["MarkdownSummariser"]},{"Source":"unoplat_code_confluence.summary_parser.codebase_summary","UsageName":["CodebaseSummaryParser"]},{"Source":"os"}],"Content":"# Standard Library"},{"NodeName":"CodeConfluenceSubPackageSignature","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/dspy_package_summary.py","MultipleExtend":["dspy.Signature"],"Imports":[{"Source":"typing","UsageName":["Dict","List"]},{"Source":"dspy"},{"Source":"unoplat_code_confluence.data_models.dspy.dspy_unoplat_node_summary","UsageName":["DspyUnoplatNodeSummary"]},{"Source":"unoplat_code_confluence.data_models.dspy.dspy_unoplat_package_summary","UsageName":["DspyUnoplatPackageSummary"]}],"Position":{"StartLine":13,"StopLine":21},"Content":"class CodeConfluenceSubPackageSignature(dspy.Signature):    \"\"\"This signature takes in existing summary of a root package and sub package summary and refines root_package_existing_summary with new insights without loosing on existing insights and returns root_package_final_summary. \"\"\"    root_package_existing_summary: str = dspy.InputField(default=\"package existing summary:\",desc=\"This will contain existing package summary\")    sub_package_summary: str = dspy.InputField(desc=\"This will contain summary of the sub package\")    sub_package_name: str = dspy.InputField(desc=\"This will contain name of the sub package\")    root_package_final_summary: str = dspy.OutputField(desc=\"This will contain improved concise package summary without loosing on existing details\")"},{"NodeName":"CodeConfluencePackageSignature","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/dspy_package_summary.py","MultipleExtend":["dspy.Signature"],"Imports":[{"Source":"typing","UsageName":["Dict","List"]},{"Source":"dspy"},{"Source":"unoplat_code_confluence.data_models.dspy.dspy_unoplat_node_summary","UsageName":["DspyUnoplatNodeSummary"]},{"Source":"unoplat_code_confluence.data_models.dspy.dspy_unoplat_package_summary","UsageName":["DspyUnoplatPackageSummary"]}],"Position":{"StartLine":21,"StopLine":29},"Content":"class CodeConfluencePackageSignature(dspy.Signature):    \"\"\"This signature takes in existing summary of root package and based on class summary of that package one at a time refines root_package_existing_summary with new insights without loosing on any existing details and returns root_package_final_summary. \"\"\"    root_package_existing_summary: str = dspy.InputField(default=\"package existing summary:\",desc=\"This will contain existing package summary\")    root_class_objective: str = dspy.InputField(desc=\"This will contain current class objective based on which existing package summary has to be enhanced\")    root_package_name: str = dspy.InputField(desc=\"This will contain name of the package\")    root_package_final_summary: str = dspy.OutputField(desc=\"This will contain improved concise package summary\")    "},{"NodeName":"CodeConfluencePackageObjectiveSignature","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/dspy_package_summary.py","MultipleExtend":["dspy.Signature"],"Imports":[{"Source":"typing","UsageName":["Dict","List"]},{"Source":"dspy"},{"Source":"unoplat_code_confluence.data_models.dspy.dspy_unoplat_node_summary","UsageName":["DspyUnoplatNodeSummary"]},{"Source":"unoplat_code_confluence.data_models.dspy.dspy_unoplat_package_summary","UsageName":["DspyUnoplatPackageSummary"]}],"Position":{"StartLine":29,"StopLine":35},"Content":"class CodeConfluencePackageObjectiveSignature(dspy.Signature):    \"\"\"This signature takes in package summary and returns concise package_objective of the package.\"\"\"    root_package_summary: str = dspy.InputField(desc=\"This will contain concise detailed implementation summary of the package\")    root_package_name: str = dspy.InputField(desc=\"This will contain name of the package\")    root_package_objective: str = dspy.OutputField(desc=\"This will contain concise objective of the package based on package summary\")"},{"NodeName":"CodeConfluencePackageModule","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/dspy_package_summary.py","MultipleExtend":["dspy.Module"],"Functions":[{"Name":"__init__","FunctionCalls":[{"NodeName":"dspy","FunctionName":"ChainOfThoughtWithHint","Position":{"StartLine":40,"StartLinePosition":46,"StopLine":40,"StopLinePosition":109}}],"Position":{"StartLine":36,"StartLinePosition":4,"StopLine":43,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"root_package_existing_summary","TypeType":""},{"TypeValue":"sub_package_summary","TypeType":""},{"TypeValue":"sub_package_name","TypeType":""},{"TypeValue":"root_package_final_summary","TypeType":""},{"TypeValue":"root_class_objective","TypeType":""},{"TypeValue":"root_package_name","TypeType":""},{"TypeValue":"root_package_summary","TypeType":""},{"TypeValue":"root_package_objective","TypeType":""},{"TypeValue":"self.generate_sub_package_summary","TypeType":"dspy"},{"TypeValue":"self.generate_package_summary","TypeType":"dspy"},{"TypeValue":"self.generate_package_objective","TypeType":"dspy"}],"Content":"def __init__(self):        super().__init__()        self.generate_sub_package_summary = dspy.ChainOfThought(CodeConfluenceSubPackageSignature)        self.generate_package_summary = dspy.ChainOfThoughtWithHint(CodeConfluencePackageSignature)        self.generate_package_objective = dspy.ChainOfThoughtWithHint(CodeConfluencePackageObjectiveSignature)            "},{"Name":"forward","Parameters":[{"TypeValue":"class_objective_list","TypeType":"List[DspyUnoplatNodeSummary]"},{"TypeValue":"package_name","TypeType":"str"},{"TypeValue":"sub_package_summaries","TypeType":"Dict[str,DspyUnoplatPackageSummary]"}],"FunctionCalls":[{"FunctionName":"DspyUnoplatPackageSummary","Position":{"StartLine":57,"StartLinePosition":56,"StopLine":57,"StopLinePosition":192}}],"Position":{"StartLine":43,"StartLinePosition":4,"StopLine":64,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"root_package_existing_summary","TypeType":""},{"TypeValue":"sub_package_summary","TypeType":""},{"TypeValue":"sub_package_name","TypeType":""},{"TypeValue":"root_package_final_summary","TypeType":""},{"TypeValue":"root_class_objective","TypeType":""},{"TypeValue":"root_package_name","TypeType":""},{"TypeValue":"root_package_summary","TypeType":""},{"TypeValue":"root_package_objective","TypeType":""},{"TypeValue":"self.generate_sub_package_summary","TypeType":"dspy"},{"TypeValue":"self.generate_package_summary","TypeType":"dspy"},{"TypeValue":"self.generate_package_objective","TypeType":"dspy"},{"TypeValue":"package_summary_hint","TypeType":""},{"TypeValue":"package_summary","TypeType":"signature_package_summary"},{"TypeValue":"signature_package_summary","TypeType":""},{"TypeValue":"package_objective_hint","TypeType":""},{"TypeValue":"package_objective_signature","TypeType":""},{"TypeValue":"dspy_package_summary","TypeType":"DspyUnoplatPackageSummary"}],"Content":"def forward(self, class_objective_list: List[DspyUnoplatNodeSummary],package_name: str,sub_package_summaries: Dict[str,DspyUnoplatPackageSummary]):                package_summary_hint=\"Enhance the package summary +:\"+package_name+\" based on class objective. Do not extrapolate or make up anything. Strictly be factual and grounded.While enhancing the package summary do not loose any existing important details by being overly concise.\"        package_summary = \"\"                for sub_package_name,sub_package_summary in sub_package_summaries.items():            package_summary = self.generate_sub_package_summary(root_package_existing_summary=package_summary,sub_package_summary=sub_package_summary.package_summary,sub_package_name=sub_package_name).root_package_final_summary        for class_objective in class_objective_list:            signature_package_summary: CodeConfluencePackageSignature = self.generate_package_summary(root_package_existing_summary=package_summary, root_class_objective=class_objective.node_objective,root_package_name=package_name,hint=package_summary_hint)            package_summary = signature_package_summary.root_package_final_summary                package_objective_hint = \"First capture all highlights from summary and based on highlights generate the package objective for the package by being concise and dnt miss on any details for:\"+package_name+\". Do not extrapolate or make up anything. Strictly be factual and grounded.\"        package_objective_signature: CodeConfluencePackageObjectiveSignature = self.generate_package_objective(root_package_summary=package_summary,root_package_name=package_name,hint=package_objective_hint)        dspy_package_summary = DspyUnoplatPackageSummary(package_objective=package_objective_signature.root_package_objective,package_summary=package_summary,class_summary=class_objective_list)        return dspy.Prediction(answer=dspy_package_summary)                             "}],"Imports":[{"Source":"typing","UsageName":["Dict","List"]},{"Source":"dspy"},{"Source":"unoplat_code_confluence.data_models.dspy.dspy_unoplat_node_summary","UsageName":["DspyUnoplatNodeSummary"]},{"Source":"unoplat_code_confluence.data_models.dspy.dspy_unoplat_package_summary","UsageName":["DspyUnoplatPackageSummary"]}],"Position":{"StartLine":35,"StopLine":64,"StopLinePosition":4},"Content":"class CodeConfluencePackageModule(dspy.Module):    def __init__(self):        super().__init__()        self.generate_sub_package_summary = dspy.ChainOfThought(CodeConfluenceSubPackageSignature)        self.generate_package_summary = dspy.ChainOfThoughtWithHint(CodeConfluencePackageSignature)        self.generate_package_objective = dspy.ChainOfThoughtWithHint(CodeConfluencePackageObjectiveSignature)            def forward(self, class_objective_list: List[DspyUnoplatNodeSummary],package_name: str,sub_package_summaries: Dict[str,DspyUnoplatPackageSummary]):                package_summary_hint=\"Enhance the package summary +:\"+package_name+\" based on class objective. Do not extrapolate or make up anything. Strictly be factual and grounded.While enhancing the package summary do not loose any existing important details by being overly concise.\"        package_summary = \"\"                for sub_package_name,sub_package_summary in sub_package_summaries.items():            package_summary = self.generate_sub_package_summary(root_package_existing_summary=package_summary,sub_package_summary=sub_package_summary.package_summary,sub_package_name=sub_package_name).root_package_final_summary        for class_objective in class_objective_list:            signature_package_summary: CodeConfluencePackageSignature = self.generate_package_summary(root_package_existing_summary=package_summary, root_class_objective=class_objective.node_objective,root_package_name=package_name,hint=package_summary_hint)            package_summary = signature_package_summary.root_package_final_summary                package_objective_hint = \"First capture all highlights from summary and based on highlights generate the package objective for the package by being concise and dnt miss on any details for:\"+package_name+\". Do not extrapolate or make up anything. Strictly be factual and grounded.\"        package_objective_signature: CodeConfluencePackageObjectiveSignature = self.generate_package_objective(root_package_summary=package_summary,root_package_name=package_name,hint=package_objective_hint)        dspy_package_summary = DspyUnoplatPackageSummary(package_objective=package_objective_signature.root_package_objective,package_summary=package_summary,class_summary=class_objective_list)        return dspy.Prediction(answer=dspy_package_summary)                             "},{"NodeName":"TotalFileCount","Type":"CLASS","FilePath":"/Users/jayghiya/.unoplat/repositories/unoplat-code-confluence/unoplat-code-confluence/unoplat_code_confluence/utility/total_file_count.py","Functions":[{"Name":"__init__","Parameters":[{"TypeValue":"directory","TypeType":""},{"TypeValue":"extension","TypeType":""}],"FunctionCalls":[{"NodeName":"logger","FunctionName":"info","Position":{"StartLine":13,"StartLinePosition":14,"StopLine":13,"StopLinePosition":101}}],"Position":{"StartLine":10,"StartLinePosition":4,"StopLine":15,"StopLinePosition":4},"LocalVariables":[{"TypeValue":"self.directory","TypeType":"directory"},{"TypeValue":"self.extension","TypeType":"extension"}],"Content":"def __init__(self, directory, extension):        self.directory = directory        self.extension = extension        logger.info(f\"FileCounter initialized with directory: {directory} and extension: {extension}\")    "},{"Name":"count_files","FunctionCalls":[{"NodeName":"logger","FunctionName":"info","Position":{"StartLine":27,"StartLinePosition":14,"StopLine":27,"StopLinePosition":54}}],"Position":{"StartLine":15,"StartLinePosition":4,"StopLine":31},"LocalVariables":[{"TypeValue":"self.directory","TypeType":"directory"},{"TypeValue":"self.extension","TypeType":""},{"TypeValue":"pattern","TypeType":"os"},{"TypeValue":"files","TypeType":"glob"}],"Content":"def count_files(self):        logger.info(\"Counting files...\")        # Ensure the extension starts with a dot        if not self.extension.startswith('.'):            self.extension = '.' + self.extension                # Create a pattern for glob to match all files with the extension        pattern = os.path.join(self.directory, '**', '*' + self.extension)                # Use glob.glob with recursive=True to find all files matching the pattern        files = glob.glob(pattern, recursive=True)                logger.info(f\"Total files found: {len(files)}\")                # Return the count of files        return len(files)"}],"Imports":[{"Source":"glob"},{"Source":"os"},{"Source":"loguru","UsageName":["logger"]}],"Position":{"StartLine":9,"StopLine":31},"Content":"class TotalFileCount:    def __init__(self, directory, extension):        self.directory = directory        self.extension = extension        logger.info(f\"FileCounter initialized with directory: {directory} and extension: {extension}\")    def count_files(self):        logger.info(\"Counting files...\")        # Ensure the extension starts with a dot        if not self.extension.startswith('.'):            self.extension = '.' + self.extension                # Create a pattern for glob to match all files with the extension        pattern = os.path.join(self.directory, '**', '*' + self.extension)                # Use glob.glob with recursive=True to find all files matching the pattern        files = glob.glob(pattern, recursive=True)                logger.info(f\"Total files found: {len(files)}\")                # Return the count of files        return len(files)"}]