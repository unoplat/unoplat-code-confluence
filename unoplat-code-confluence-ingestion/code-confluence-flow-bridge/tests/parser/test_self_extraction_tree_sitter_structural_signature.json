{
  "module_docstring": "\nTree-sitter structural signature extractor for code parsing.\n\nThis module provides Python-specific structural signature extraction using tree-sitter.\n",
  "global_variables": [],
  "functions": [],
  "classes": [
    {
      "start_line": 29,
      "end_line": 896,
      "signature": "class TreeSitterPythonStructuralSignatureExtractor(TreeSitterExtractorBase):",
      "docstring": "Extracts structural signatures from Python source code using tree-sitter queries.\n\n    Inherits caching utilities from TreeSitterExtractorBase and implements\n    Python-specific extraction logic for functions, classes, variables, etc.\n    ",
      "vars": [],
      "methods": [
        {
          "start_line": 36,
          "end_line": 43,
          "signature": "def __init__(self, language_name: str, config: TreeSitterExtractorConfig):",
          "docstring": "Initialize parser & queries with multi-level caching and lazy compilation.\n\n        Args:\n            language_name: Programming language name (should be \"python\")\n            config: TreeSitterExtractorConfig with query paths, captures, and node types\n        ",
          "function_calls": [
            "super().__init__(language_name, config)",
            "super()"
          ],
          "nested_functions": [],
          "instance_variables": []
        },
        {
          "start_line": 46,
          "end_line": 49,
          "signature": "@property\n    def _LANGUAGE_CACHE(self) -> Dict[str, tree_sitter.Language]:",
          "docstring": "Expose module-level language cache for test introspection.",
          "function_calls": [],
          "nested_functions": [],
          "instance_variables": []
        },
        {
          "start_line": 51,
          "end_line": 54,
          "signature": "@property\n    def _PARSER_CACHE(self) -> Dict[str, tree_sitter.Parser]:",
          "docstring": "Expose module-level parser cache for test introspection.",
          "function_calls": [],
          "nested_functions": [],
          "instance_variables": []
        },
        {
          "start_line": 56,
          "end_line": 59,
          "signature": "@property\n    def _QUERY_CACHE(self) -> Dict[str, Dict[str, tree_sitter.Query]]:",
          "docstring": "Expose module-level query cache for test introspection.",
          "function_calls": [],
          "nested_functions": [],
          "instance_variables": []
        },
        {
          "start_line": 61,
          "end_line": 86,
          "signature": "def extract_structural_signature(\n        self, source_bytes: bytes\n    ) -> PythonStructuralSignature:",
          "docstring": "Extract structural signature from byte content.",
          "function_calls": [
            "self.parser.parse(source_bytes)",
            "self._extract_module_docstring(\n            root_node, source_bytes\n        )",
            "self._extract_global_variables(\n            root_node, source_bytes\n        )",
            "self._extract_functions(\n            root_node, source_bytes\n        )",
            "self._extract_classes(root_node, source_bytes)",
            "PythonStructuralSignature(\n            module_docstring=module_docstring,\n            global_variables=global_variables,\n            functions=functions,\n            classes=classes,\n        )"
          ],
          "nested_functions": [],
          "instance_variables": []
        },
        {
          "start_line": 88,
          "end_line": 101,
          "signature": "def _extract_module_docstring(\n        self, root_node: tree_sitter.Node, source: bytes\n    ) -> Optional[str]:",
          "docstring": "Extract module-level docstring.",
          "function_calls": [
            "tree_sitter.QueryCursor(self.queries[\"module_docstring\"])",
            "cursor.captures(root_node)",
            "self.config.get_capture_name(\"module\")",
            "source[node.start_byte : node.end_byte].decode(\"utf-8\")",
            "self._clean_string_literal(docstring)"
          ],
          "nested_functions": [],
          "instance_variables": []
        },
        {
          "start_line": 103,
          "end_line": 134,
          "signature": "def _extract_global_variables(\n        self, root_node: tree_sitter.Node, source: bytes\n    ) -> List[PythonVariableInfo]:",
          "docstring": "Extract module-level variable declarations.",
          "function_calls": [
            "tree_sitter.QueryCursor(self.queries[\"global_variables\"])",
            "cursor.captures(root_node)",
            "set()",
            "self.config.get_capture_name(\"var_statement\")",
            "self._is_at_module_level(node)",
            "source[node.start_byte : node.end_byte].decode(\"utf-8\").strip()",
            "source[node.start_byte : node.end_byte].decode(\"utf-8\")",
            "seen_assignments.add((start_line, signature))",
            "variables.append(\n                            PythonVariableInfo(\n                                start_line=start_line,\n                                end_line=end_line,\n                                signature=signature,\n                            )\n                        )",
            "PythonVariableInfo(\n                                start_line=start_line,\n                                end_line=end_line,\n                                signature=signature,\n                            )"
          ],
          "nested_functions": [],
          "instance_variables": []
        },
        {
          "start_line": 136,
          "end_line": 220,
          "signature": "def _extract_functions(\n        self, root_node: tree_sitter.Node, source: bytes\n    ) -> List[PythonFunctionInfo]:",
          "docstring": "Extract module-level function definitions using matches.",
          "function_calls": [
            "tree_sitter.QueryCursor(self.queries[\"module_functions\"])",
            "cursor.matches(root_node)",
            "set()",
            "self.config.get_capture_name(\n                \"func_with_decorators\"\n            )",
            "self._is_at_module_level(func_node)",
            "source[\n                    func_node.start_byte : func_node.end_byte\n                ].decode(\"utf-8\")",
            "signature.split(\"\\n\")",
            "sig_parts.append(line)",
            "line.rstrip()",
            "line.rstrip().endswith(\":\")",
            "self.config.get_capture_name(\n                    \"function\"\n                )",
            "self._clean_string_literal(\n                        source[\n                            docstring_node.start_byte : docstring_node.end_byte\n                        ].decode(\"utf-8\")\n                    )",
            "source[\n                            docstring_node.start_byte : docstring_node.end_byte\n                        ].decode(\"utf-8\")",
            "captures.get(function_node_cap, [None])",
            "self._extract_nested_functions_for_node(\n                        actual_func_def, source\n                    )",
            "self._extract_function_calls_for_node(\n                        actual_func_def, source\n                    )",
            "\"\\n\".join(sig_parts)",
            "seen.add(key)",
            "functions.append(\n                        PythonFunctionInfo(\n                            start_line=start_line,\n                            end_line=end_line,\n                            signature=func_sig,\n                            docstring=docstring,\n                            function_calls=function_calls,\n                            nested_functions=nested_functions,\n                        )\n                    )",
            "PythonFunctionInfo(\n                            start_line=start_line,\n                            end_line=end_line,\n                            signature=func_sig,\n                            docstring=docstring,\n                            function_calls=function_calls,\n                            nested_functions=nested_functions,\n                        )",
            "sorted(functions, key=lambda f: f.start_line)"
          ],
          "nested_functions": [],
          "instance_variables": []
        },
        {
          "start_line": 222,
          "end_line": 316,
          "signature": "def _extract_classes(\n        self, root_node: tree_sitter.Node, source: bytes\n    ) -> List[PythonClassInfo]:",
          "docstring": "Extract class definitions with their methods and variables using matches.",
          "function_calls": [
            "tree_sitter.QueryCursor(self.queries[\"module_classes\"])",
            "cursor.matches(root_node)",
            "self.config.get_capture_name(\"class_with_decorators\")",
            "self.config.get_capture_name(\"class_def\")",
            "source[class_node.start_byte : class_node.end_byte].decode(\n                    \"utf-8\"\n                )",
            "signature.split(\"\\n\")",
            "sig_parts.append(line)",
            "line.rstrip()",
            "line.rstrip().endswith(\":\")",
            "self.config.get_capture_name(\"class\")",
            "self._clean_string_literal(\n                        source[\n                            docstring_node.start_byte : docstring_node.end_byte\n                        ].decode(\"utf-8\")\n                    )",
            "source[\n                            docstring_node.start_byte : docstring_node.end_byte\n                        ].decode(\"utf-8\")",
            "self._extract_class_variables_for_node(\n                        actual_class_def, source\n                    )",
            "self._extract_methods_for_node(actual_class_def, source)",
            "self._extract_nested_classes_for_node(\n                        actual_class_def, source\n                    )",
            "class_variables.copy()",
            "set()",
            "instance_var.signature.split(\"=\")[0].strip()",
            "instance_var.signature.split(\"=\")",
            "instance_variables_seen.add(var_key)",
            "all_variables.append(instance_var)",
            "all_variables.sort(key=lambda v: v.start_line)",
            "classes.append(\n                    PythonClassInfo(\n                        start_line=start_line,\n                        end_line=end_line,\n                        signature=\"\\n\".join(sig_parts),\n                        docstring=docstring,\n                        vars=all_variables,\n                        methods=methods,\n                        nested_classes=nested_classes,\n                    )\n                )",
            "PythonClassInfo(\n                        start_line=start_line,\n                        end_line=end_line,\n                        signature=\"\\n\".join(sig_parts),\n                        docstring=docstring,\n                        vars=all_variables,\n                        methods=methods,\n                        nested_classes=nested_classes,\n                    )",
            "\"\\n\".join(sig_parts)",
            "sorted(classes, key=lambda c: c.start_line)"
          ],
          "nested_functions": [],
          "instance_variables": []
        },
        {
          "start_line": 318,
          "end_line": 362,
          "signature": "def _extract_class_variables_for_node(\n        self, class_node: tree_sitter.Node, source: bytes\n    ) -> List[PythonVariableInfo]:",
          "docstring": "Extract class variables for a specific class node, excluding nested class variables.",
          "function_calls": [
            "tree_sitter.QueryCursor(self.queries[\"class_variables\"])",
            "cursor.captures(class_node)",
            "self._get_nested_class_ranges(class_node)",
            "set()",
            "self.config.get_capture_name(\"var_statement\")",
            "any(\n                    start <= assignment_start < end for start, end in nested_ranges\n                )",
            "source[node.start_byte : node.end_byte].decode(\"utf-8\").strip()",
            "source[node.start_byte : node.end_byte].decode(\"utf-8\")",
            "seen.add(key)",
            "variables.append(\n                        PythonVariableInfo(\n                            start_line=start_line,\n                            end_line=end_line,\n                            signature=signature,\n                        )\n                    )",
            "PythonVariableInfo(\n                            start_line=start_line,\n                            end_line=end_line,\n                            signature=signature,\n                        )"
          ],
          "nested_functions": [],
          "instance_variables": []
        },
        {
          "start_line": 364,
          "end_line": 456,
          "signature": "def _extract_methods_for_node(\n        self, class_node: tree_sitter.Node, source: bytes\n    ) -> List[PythonFunctionInfo]:",
          "docstring": "Extract methods for a specific class node using matches, excluding nested class methods.",
          "function_calls": [
            "tree_sitter.QueryCursor(self.queries[\"class_methods\"])",
            "cursor.matches(class_node)",
            "self._get_nested_class_ranges(class_node)",
            "self.config.get_capture_name(\n                \"method_with_decorators\"\n            )",
            "self.config.get_capture_name(\"method_def\")",
            "any(\n                    start <= method_start < end for start, end in nested_ranges\n                )",
            "source[\n                    method_node.start_byte : method_node.end_byte\n                ].decode(\"utf-8\")",
            "signature.split(\"\\n\")",
            "sig_parts.append(line)",
            "line.rstrip()",
            "line.rstrip().endswith(\":\")",
            "self.config.get_capture_name(\"method\")",
            "self._clean_string_literal(\n                        source[\n                            docstring_node.start_byte : docstring_node.end_byte\n                        ].decode(\"utf-8\")\n                    )",
            "source[\n                            docstring_node.start_byte : docstring_node.end_byte\n                        ].decode(\"utf-8\")",
            "captures.get(method_def_cap, [None])",
            "self._extract_nested_functions_for_node(\n                        actual_method_def, source\n                    )",
            "self._extract_function_calls_for_node(\n                        actual_method_def, source\n                    )",
            "self._extract_instance_variables_for_method(\n                        actual_method_def, source\n                    )",
            "methods.append(\n                    PythonFunctionInfo(\n                        start_line=start_line,\n                        end_line=end_line,\n                        signature=\"\\n\".join(sig_parts),\n                        docstring=docstring,\n                        function_calls=function_calls,\n                        nested_functions=nested_functions,\n                        instance_variables=instance_variables,\n                    )\n                )",
            "PythonFunctionInfo(\n                        start_line=start_line,\n                        end_line=end_line,\n                        signature=\"\\n\".join(sig_parts),\n                        docstring=docstring,\n                        function_calls=function_calls,\n                        nested_functions=nested_functions,\n                        instance_variables=instance_variables,\n                    )",
            "\"\\n\".join(sig_parts)",
            "sorted(methods, key=lambda m: m.start_line)"
          ],
          "nested_functions": [],
          "instance_variables": []
        },
        {
          "start_line": 459,
          "end_line": 540,
          "signature": "def _extract_nested_functions_for_node(\n        self, parent_func_node: tree_sitter.Node, source: bytes\n    ) -> List[PythonFunctionInfo]:",
          "docstring": "Extract immediate nested functions within a specific function node.\n\n        This method only extracts functions that are direct children of the parent\n        function, not grandchildren or deeper descendants. Each extracted function\n        is recursively processed to find its own nested functions.\n        ",
          "function_calls": [
            "tree_sitter.QueryCursor(self.queries[\"nested_functions\"])",
            "cursor.matches(parent_func_node)",
            "self.config.get_capture_name(\n                \"nested_func_with_decorators\"\n            )",
            "self.config.get_capture_name(\"nested_func_def\")",
            "self._is_immediate_child_function(\n                    nested_func_node, parent_func_node\n                )",
            "source[\n                    nested_func_node.start_byte : nested_func_node.end_byte\n                ].decode(\"utf-8\")",
            "signature.split(\"\\n\")",
            "sig_parts.append(line)",
            "line.rstrip()",
            "line.rstrip().endswith(\":\")",
            "self.config.get_capture_name(\"nested_function\")",
            "self._clean_string_literal(\n                        source[\n                            docstring_node.start_byte : docstring_node.end_byte\n                        ].decode(\"utf-8\")\n                    )",
            "source[\n                            docstring_node.start_byte : docstring_node.end_byte\n                        ].decode(\"utf-8\")",
            "captures.get(\n                    nested_def_cap, [None]\n                )",
            "self._extract_nested_functions_for_node(\n                        actual_nested_def, source\n                    )",
            "nested_functions.append(\n                    PythonFunctionInfo(\n                        start_line=start_line,\n                        end_line=end_line,\n                        signature=\"\\n\".join(sig_parts),\n                        docstring=docstring,\n                        function_calls=self._extract_function_calls_for_node(\n                            nested_func_node, source\n                        ),\n                        nested_functions=deeper_nested_functions,\n                    )\n                )",
            "PythonFunctionInfo(\n                        start_line=start_line,\n                        end_line=end_line,\n                        signature=\"\\n\".join(sig_parts),\n                        docstring=docstring,\n                        function_calls=self._extract_function_calls_for_node(\n                            nested_func_node, source\n                        ),\n                        nested_functions=deeper_nested_functions,\n                    )",
            "\"\\n\".join(sig_parts)",
            "self._extract_function_calls_for_node(\n                            nested_func_node, source\n                        )",
            "sorted(nested_functions, key=lambda f: f.start_line)"
          ],
          "nested_functions": [],
          "instance_variables": []
        },
        {
          "start_line": 542,
          "end_line": 549,
          "signature": "def _is_at_module_level(self, node: tree_sitter.Node) -> bool:",
          "docstring": "Check if a node is at top-level scope using language config.",
          "function_calls": [],
          "nested_functions": [],
          "instance_variables": []
        },
        {
          "start_line": 551,
          "end_line": 553,
          "signature": "def _clean_string_literal(self, string_literal: str) -> str:",
          "docstring": "Delegate string cleaning to language config.",
          "function_calls": [
            "self.config.doc_cleaner(string_literal)"
          ],
          "nested_functions": [],
          "instance_variables": []
        },
        {
          "start_line": 555,
          "end_line": 581,
          "signature": "def _is_immediate_child_function(\n        self, child_node: tree_sitter.Node, parent_func_node: tree_sitter.Node\n    ) -> bool:",
          "docstring": "Check if a function node is an immediate child of the parent function.\n\n        This method traverses upward from the child node through any block nodes\n        to determine if it's directly nested within the parent function, not a\n        grandchild or deeper descendant.\n\n        Args:\n            child_node: The potential nested function node\n            parent_func_node: The parent function being analyzed\n\n        Returns:\n            True if child_node is an immediate child of parent_func_node\n        ",
          "function_calls": [],
          "nested_functions": [],
          "instance_variables": []
        },
        {
          "start_line": 587,
          "end_line": 627,
          "signature": "def _get_nested_function_ranges(\n        self, func_node: tree_sitter.Node\n    ) -> List[Tuple[int, int]]:",
          "docstring": "Get byte ranges of immediate nested functions within a function node.\n\n        Only returns ranges for functions that are direct children of the given\n        function node, not grandchildren or deeper descendants.\n\n        Returns:\n            List of (start_byte, end_byte) tuples for each immediate child function.\n        ",
          "function_calls": [
            "tree_sitter.QueryCursor(self.queries[\"nested_functions\"])",
            "cursor.matches(func_node)",
            "self.config.get_capture_name(\n                \"nested_func_with_decorators\"\n            )",
            "self.config.get_capture_name(\"nested_func_def\")",
            "self._is_immediate_child_function(nested_func_node, func_node)",
            "nested_ranges.append(\n                    (nested_func_node.start_byte, nested_func_node.end_byte)\n                )"
          ],
          "nested_functions": [],
          "instance_variables": []
        },
        {
          "start_line": 629,
          "end_line": 666,
          "signature": "def _get_nested_class_ranges(\n        self, class_node: tree_sitter.Node\n    ) -> List[Tuple[int, int]]:",
          "docstring": "Get byte ranges of immediate nested classes within a class node.\n\n        Only returns ranges for classes that are direct children of the given\n        class node, not grandchildren or deeper descendants.\n\n        Returns:\n            List of (start_byte, end_byte) tuples for each immediate child class.\n        ",
          "function_calls": [
            "tree_sitter.QueryCursor(self.queries[\"nested_classes\"])",
            "cursor.matches(class_node)",
            "self.config.get_capture_name(\n                \"nested_class_with_decorators\"\n            )",
            "self.config.get_capture_name(\"nested_class_def\")",
            "nested_ranges.append(\n                    (nested_class_node.start_byte, nested_class_node.end_byte)\n                )"
          ],
          "nested_functions": [],
          "instance_variables": []
        },
        {
          "start_line": 668,
          "end_line": 728,
          "signature": "def _extract_function_calls_for_node(\n        self,\n        func_node: tree_sitter.Node,\n        source: bytes,\n        start_line: Optional[int] = None,\n        end_line: Optional[int] = None,\n    ) -> List[str]:",
          "docstring": "Extract function call names inside a function node via language-specific query.\n\n        This routine relies entirely on the `function_calls` query defined per\n        language. Any language wishing to support call-tracking must provide\n        a `function_calls.scm` under its queries directory and capture the\n        callable expression as `@function_call` (or the language-specific\n        alias specified via :py:meth:`LanguageConfig.cap`).\n\n        This method now filters out calls that are within nested functions,\n        returning only direct calls within the function body.\n\n        Args:\n            func_node: The function AST node\n            source: The full source code\n            start_line: Deprecated parameter (kept for compatibility)\n            end_line: Deprecated parameter (kept for compatibility)\n        ",
          "function_calls": [
            "tree_sitter.QueryCursor(self.queries[\"function_calls\"])",
            "cursor.captures(func_node)",
            "self.config.get_capture_name(\"function_call\")",
            "self._get_nested_function_ranges(func_node)",
            "any(\n                start <= call_start < end for start, end in nested_ranges\n            )",
            "direct_call_nodes.append(call_node)",
            "sorted(direct_call_nodes, key=lambda n: n.start_byte)",
            "source[n.start_byte : n.end_byte].decode(\"utf-8\").strip()",
            "source[n.start_byte : n.end_byte].decode(\"utf-8\")"
          ],
          "nested_functions": [],
          "instance_variables": []
        },
        {
          "start_line": 730,
          "end_line": 796,
          "signature": "def _extract_instance_variables_for_method(\n        self, method_node: tree_sitter.Node, source: bytes\n    ) -> List[PythonVariableInfo]:",
          "docstring": "Extract instance variable assignments from a method node.\n\n        This method extracts assignments to instance variables (self.* assignments)\n        within a method body, filtering out assignments within nested functions.\n\n        Args:\n            method_node: The method AST node\n            source: The full source code\n\n        Returns:\n            List of PythonVariableInfo objects for instance variable assignments\n        ",
          "function_calls": [
            "tree_sitter.QueryCursor(self.queries[\"instance_variables\"])",
            "cursor.captures(method_node)",
            "self._get_nested_function_ranges(method_node)",
            "any(\n                start <= assignment_start < end for start, end in nested_ranges\n            )",
            "direct_assignment_nodes.append(assignment_node)",
            "set()",
            "source[node.start_byte : node.end_byte].decode(\"utf-8\").strip()",
            "source[node.start_byte : node.end_byte].decode(\"utf-8\")",
            "assignment_text.startswith(\"self.\")",
            "seen.add(key)",
            "instance_variables.append(\n                        PythonVariableInfo(\n                            start_line=start_line,\n                            end_line=end_line,\n                            signature=assignment_text,\n                        )\n                    )",
            "PythonVariableInfo(\n                            start_line=start_line,\n                            end_line=end_line,\n                            signature=assignment_text,\n                        )",
            "sorted(instance_variables, key=lambda v: v.start_line)"
          ],
          "nested_functions": [],
          "instance_variables": []
        },
        {
          "start_line": 798,
          "end_line": 896,
          "signature": "def _extract_nested_classes_for_node(\n        self, class_node: tree_sitter.Node, source: bytes\n    ) -> List[PythonClassInfo]:",
          "docstring": "Extract nested class definitions within a class node.",
          "function_calls": [
            "tree_sitter.QueryCursor(self.queries[\"nested_classes\"])",
            "cursor.matches(class_node)",
            "self.config.get_capture_name(\n                \"nested_class_with_decorators\"\n            )",
            "self.config.get_capture_name(\"nested_class_def\")",
            "source[\n                    nested_node.start_byte : nested_node.end_byte\n                ].decode(\"utf-8\")",
            "signature.split(\"\\n\")",
            "sig_parts.append(line)",
            "line.rstrip()",
            "line.rstrip().endswith(\":\")",
            "self.config.get_capture_name(\"nested_class\")",
            "self._clean_string_literal(\n                        source[\n                            docstring_node.start_byte : docstring_node.end_byte\n                        ].decode(\"utf-8\")\n                    )",
            "source[\n                            docstring_node.start_byte : docstring_node.end_byte\n                        ].decode(\"utf-8\")",
            "self._extract_class_variables_for_node(\n                        actual_nested_def, source\n                    )",
            "self._extract_methods_for_node(actual_nested_def, source)",
            "self._extract_nested_classes_for_node(\n                        actual_nested_def, source\n                    )",
            "class_variables.copy()",
            "set()",
            "instance_var.signature.split(\"=\")",
            "instance_var.signature.split(\"=\")[0].strip()",
            "instance_variables_seen.add(var_key)",
            "all_variables.append(instance_var)",
            "all_variables.sort(key=lambda v: v.start_line)",
            "nested_classes.append(\n                    PythonClassInfo(\n                        start_line=start_line,\n                        end_line=end_line,\n                        signature=\"\\n\".join(sig_parts),\n                        docstring=docstring,\n                        vars=all_variables,\n                        methods=methods,\n                        nested_classes=deeper_nested,\n                    )\n                )",
            "PythonClassInfo(\n                        start_line=start_line,\n                        end_line=end_line,\n                        signature=\"\\n\".join(sig_parts),\n                        docstring=docstring,\n                        vars=all_variables,\n                        methods=methods,\n                        nested_classes=deeper_nested,\n                    )",
            "\"\\n\".join(sig_parts)",
            "sorted(nested_classes, key=lambda c: c.start_line)"
          ],
          "nested_functions": [],
          "instance_variables": []
        }
      ],
      "nested_classes": []
    }
  ]
}