Defining Theme and Style Items in the Shadcn UI Registry

Official Structure of registry:theme and registry:style Items

In the Shadcn UI component registry, themes and styles are special item types with their own schema rules. A style item is defined with "type": "registry:style" and typically includes metadata like name, optional title/description, dependencies, and CSS variables. For example, a custom style might include an array of dependencies (npm packages) and registryDependencies (other registry items to pull in) along with a cssVars object for design tokens ￼. The cssVars is where you define theme tokens (e.g. fonts) under a "theme" key and color values under "light" and "dark" keys for light/dark modes ￼. Styles can also specify an extends field – for instance, "extends": "none" indicates a style that does not inherit from the default Shadcn style (allowing you to start from scratch) ￼ ￼.

A theme item is defined similarly, using "type": "registry:theme". Theme items focus on providing a set of CSS variables (generally color palette values) for different color schemes. Unlike styles, themes usually don’t list dependencies or extends – they primarily contain a cssVars section with light and dark entries mapping semantic color names to values. For example, a registry:theme item might define keys like "background", "foreground", "primary", etc., each with light and dark OKLCH or HSL color values ￼. Both theme and style JSON definitions follow the registry-item.json schema (with $schema pointing to Shadcn’s schema URL) and must have a unique name field ￼ ￼. Importantly, registry:style (e.g. the built-in “new-york” style) and registry:theme are recognized types in this schema ￼, meaning the CLI knows to handle them differently from regular components or files.

Inline Definitions vs External File References

Official documentation and examples strongly favor inline definitions of theme and style items, rather than splitting their contents into external files. In practice, this means you define all relevant fields (like cssVars) within the JSON object of the item itself. The Shadcn UI docs provide sample JSON for a style item showing the CSS variables defined inline in the item JSON ￼, and similarly a theme example item lists its light/dark variables directly in the JSON ￼. There is no need to use a files[] array to reference separate JSON files for theme or style definitions – in fact, the schema is designed for these items to be self-contained. Each registry:style or registry:theme is essentially its own JSON file (or entry in the registry) defining the design tokens and does not usually produce a physical code file to copy into your project.

While it is technically possible to reference external files via the files array in a registry item, this mechanism is intended for code or asset files (components, pages, utilities, etc.), not for linking other JSON configs. The files[].type property is meant to specify file types like registry:component, registry:hook, registry:page, or registry:file (for arbitrary files) that the CLI will copy into the project structure ￼ ￼. There is no official support for a files entry of type registry:theme or registry:style inside another item – those types are reserved for top-level registry items, not nested file references ￼. If you attempted to put a theme’s JSON in a files array, you would have to mislabel it (perhaps as registry:file), provide a dummy target path, and the CLI would just treat it as a file to copy (which doesn’t align with how themes/styles are applied). In short, Shadcn’s registry expects you to define themes and styles inline as first-class registry items, rather than as file references.

Pros of inline definitions: This approach keeps the registry item self-contained and easier to distribute or reference by URL (since each item JSON can be fetched independently). It aligns with the schema validation, so your JSON will pass the official schema checks without errors. Inline definitions also allow the Shadcn CLI to properly interpret your theme/style – for example, installing a registry:style item via the CLI will automatically apply its cssVars and dependencies, because the CLI can read them directly from the item JSON ￼ ￼. Another benefit is clarity: anyone reading your registry JSON or browsing your custom registry can immediately see what variables or tokens your style/theme defines.

Cons of inline definitions: In some cases, the JSON item can become large or repetitive if you have many design tokens. For instance, defining an entire palette for light and dark mode in one JSON object could be verbose. There’s also a slight coupling: if multiple style items were meant to share a large set of variables, you’d have to duplicate or maintain them in each item (since you’re not pulling from a single external source). However, this is usually mitigated by the fact that you’ll choose one primary style per project, and you can use the extends mechanism or base styles to avoid duplicating all tokens from scratch.

Pros of using a files reference (hypothetical): The idea of splitting the theme or style into a separate JSON file might appeal for organizational purposes. In theory, a style item’s files array could reference a JSON containing just cssVars, which might make the main registry.json cleaner. It could also allow reuse of the same theme file across multiple style variants (if the system supported it). For example, two custom styles could potentially reference a common color theme file so that a change in that file updates both – but note, this is not an officially documented pattern.

Cons of external file references: In practice, this approach is not recommended due to schema and tooling limitations. The registry schema expects each file in files[] to include a target if it’s a generic or page file, meaning you’d have to specify where to copy the JSON in the user’s project ￼ ￼ (which usually doesn’t make sense for theme/style data). Moreover, using a file of type registry:theme inside another item will likely fail validation – the JSON schema has specific accepted values for type, and a context expecting a file might not accept a top-level item type in that spot. Many users have encountered errors like “Value is not accepted” when trying such unconventional setups, indicating the value provided for type or a missing required field isn’t matching the schema. For example, if you tried to put { "path": "my-theme.json", "type": "registry:theme" } in a files array, the validator would complain because registry:theme isn’t an allowed file type in that context (expected values would be things like registry:component, etc.) – the correct way is to treat the theme as its own item, not a sub-file. In addition, if you use registry:file to sneak it in, you’d still need a target path, and the CLI would drop that JSON into your project (which is not how themes are usually applied). These workarounds are brittle and not supported by official docs, so they tend to cause more problems (and confusing errors) than they solve.

Schema Validation Considerations and Common Pitfalls

To avoid schema validation issues when defining theme and style items, it’s important to follow the official schema rules. First, always include the appropriate $schema reference at the top of your JSON (e.g. https://ui.shadcn.com/schema/registry-item.json) so that your editor/validator knows how to validate it ￼. This will help catch mistakes early. Ensure the type property is one of the accepted strings – use exactly "registry:style" for style items or "registry:theme" for theme items ￼. Typos or unsupported types will yield a “value is not accepted. Valid values: […]” error in most JSON schema validators.

A common pitfall is misplacing the definition of a theme or style. As discussed, do not nest a theme inside another item’s files. Each theme or style should be its own JSON entry either in your registry.json or as a standalone file that the registry build process will include. If you maintain a registry.json manifest, list the theme/style item just like a component, giving its name and type. For example, you might have an entry: { "name": "custom-theme", "type": "registry:theme", "cssVars": { ... } } in the items array of registry.json. This way, the theme is a first-class item and will pass validation.

Another schema rule to note: if you use a registry:file type for any file (which should only be for things like config files or static assets), you must provide a target path where it should be placed in the consumer’s project ￼. Forgetting the target on a registry:file will cause a validation error. This is relevant if, say, your style item needs to install a config (like a .env or custom Tailwind config extension) – in that case, use type: "registry:file" and supply a "target": "~/path/to/destination" in that file entry ￼. However, for theme/style definitions themselves, you normally won’t use registry:file at all (since they aren’t copied into the project as files). All their effect is through the CLI updating your Tailwind config or CSS.

“Value is not accepted” errors generally indicate you’ve provided a value outside the allowed enumeration or pattern. For instance, using "extends": "none" is valid for styles (as shown in examples) but using "extends": "someStyleName" other than "none" or omitting it is something to be careful with – the docs only demonstrate "none" or leaving it out to inherit the default. If you put an unexpected string in extends, the schema might not recognize it (it’s likely an enum of "none" or perhaps certain base style names). When in doubt, check the official examples and copy their field naming exactly ￼ ￼. Another tip: make sure your cssVars object has the correct structure. It should have at most three top-level keys: "theme" (for global tokens like fonts or sizing that apply regardless of light/dark), "light", and "dark" for color modes ￼. Missing one of the required mode keys, or adding extra keys, could cause validation to fail. Stick to defining known CSS variable names (like --background, --foreground, etc. as seen in Shadcn’s theme presets) under those light/dark sections.

In summary, follow the schema and examples closely and you’ll avoid most validation issues. Use the provided JSON schemas (which you can find on the Shadcn site) as a reference for what’s allowed, and validate your custom registry items against them during development.

Recommended Patterns and Best Practices for Themes & Styles

Defining custom styles: If you want to create your own style (a set of baseline component styles and default design tokens), the best practice is to start by extending the default Shadcn style unless you have a reason to start fresh. By default, if you omit an extends field, your registry:style item will inherit from Shadcn’s base style (currently the “new-york” design) ￼. This means you only need to override or add variables that differ – for example, you might just add a new brand color or change a font. The docs illustrate a “Custom colors” style item that simply adds a new brand color to the default palette, without specifying extends (thus inheriting all other defaults) ￼ ￼. On the other hand, if you truly want to build a style from scratch, use "extends": "none" and then define all the necessary cssVars and components that your style needs ￼ ￼. Starting from none means nothing is pre-included – you are responsible for providing all tokens (colors, radii, etc.) that components will use. In that case, you’ll likely also pull in core components or utilities via registryDependencies (for example, the Shadcn base utils item, plus specific components you plan to style) ￼ ￼. This effectively lets you fork the design system. Keep in mind that whichever style you choose at project init is essentially locked in for that project’s components – as the Shadcn docs note, “The style for your components… cannot be changed after initialization.” ￼. So choose the style (default or custom) upfront, as switching later would require regenerating or adjusting all component code.

Defining custom themes: A theme in Shadcn UI is essentially a color scheme (and possibly other cosmetic tokens) that can be applied on top of a style. The recommended pattern is to define a registry:theme item with the name of your theme (e.g. "name": "acme-corp-theme" or "solarized-theme" etc.) and list the CSS variable values for light and dark mode in its cssVars. Typically, you’d include all the color variables that the components use – for example, the background and foreground colors, primary colors, ring (focus ring) color, sidebar colors, etc., matching the keys used in the default theme. By providing a full set, you ensure your theme is comprehensive. In many cases, the easiest way to create a custom theme is to start from Shadcn’s theme examples or presets. Shadcn’s website provides pre-made theme JSON (or CSS) for various color palettes which you can use as a template. You can copy one of those, adjust values as needed, and include it as a registry:theme in your registry.

Linking styles and themes: How do style and theme items relate? In the current Shadcn system, a style defines the overall component structure and default tokens, and a theme can override mainly the color tokens. You might think of the style as “how components look and are composed” (margins, fonts, default sizing, etc.), and the theme as “which color swatch is applied”. In practice, if you want to use a custom theme in your project, you would add that theme via the CLI after initializing with your chosen style. For example, suppose your components.json has "style": "new-york" (the default style) ￼, but you want a custom color theme named "custom-theme" from your registry. You could run the Shadcn CLI to add the theme item (e.g. npx shadcn add custom-theme if the CLI supports adding themes like other components). The CLI, upon installing a registry:theme item, will merge its CSS variables into your project’s output. This usually means updating your Tailwind configuration or your CSS file to include the new :root and .dark variables. In older versions (Tailwind v3), the CLI might directly inject those variables into globals.css under @layer base. In Tailwind v4, the approach uses the @theme directive with an inline option, as Shadcn’s team has updated the methodology for defining CSS variables ￼ ￼. The key point is that adding a theme item from the registry should automatically take care of applying those CSS variable values in the right place, so you don’t have to manually copy-paste them.

One best practice gleaned from the community is to keep theme and style separate until you need to combine them. You might maintain multiple theme variants for your design system (e.g., a default theme, a dim theme, a high-contrast theme) as distinct registry:theme items. Each can be added or switched in the project as needed (with some manual toggling logic, usually via something like next-themes for React to toggle data-theme or class on <html>). Meanwhile, you typically have only one active style in a project (since you can’t mix two different styles easily at runtime – that would mean two different sets of component code). If you do create multiple styles (say, a “compact” style vs a “spacious” style, or brand A vs brand B components that differ in more than just color), those would likely be used in separate projects or via separate initializations.

Avoiding schema issues and ensuring compatibility: Always test your custom registry items by running the Shadcn CLI commands on a sample project. If you encounter errors, re-check that your JSON item conforms to examples. For instance, if a theme isn’t applying, ensure you included all necessary color variables. The Shadcn default style expects certain CSS variables to exist – missing ones could result in components falling back to default colors or not styling correctly. You can compare your theme’s keys with the default theme keys shown in the Shadcn documentation. It’s also worth reading any relevant GitHub discussions for updates. As of early 2024, there were reports that copying theme code from the website required small tweaks due to changes in Tailwind v4 (moving the :root out of @layer base, etc.) ￼ ￼. The Shadcn maintainers have likely adjusted the CLI or documentation to account for this, but the takeaway is to follow the latest recommended format (e.g. using @theme inline for Tailwind v4 projects, which the CLI will handle when using cssVars properly).

In summary, the recommended pattern is: define your style item (usually extending “new-york” unless you need a completely custom build) with any customizations and tokens inline, and define one or more theme items with full color variable sets inline. Use the CLI to initialize your project with the chosen style (set in components.json), then add a theme item if you want to override the color scheme. This separation of concerns keeps your base components consistent while allowing color-swapping when needed. It also adheres to the official schema, avoiding validation errors. By following these practices, you leverage the Shadcn registry system as intended – making your UI library easily maintainable and sharable across projects with minimal friction ￼ ￼.

Interaction with components.json and CLI Behavior

The components.json file in a Shadcn-enabled project is where you specify global settings, including which style to use. The "style" field here should match the name of the style item you want to apply to all components in the project ￼. For example, the official template uses "style": "new-york" (since the default style is now called “new-york”) ￼. If you created a custom style in your own registry called "acme-style", you would put "style": "acme-style" in your components.json before running the shadcn init command. During initialization, the CLI will look at that style name and fetch the corresponding style item from the registry. It then applies it by installing any dependencies listed and setting up the CSS variables in your project’s Tailwind config or CSS as defined by the style. The Shadcn docs emphasize that you should choose the style at init time because switching later is not straightforward (it would require re-running the code generation for a different style) ￼.

When adding components via the CLI (shadcn add component-name), the CLI also respects the chosen style. This means it will pull the component code that matches your style’s conventions. For instance, if your style uses certain class names or expects certain CSS variables, the component templates from your registry should be aligned to that. In a custom registry, you might have overridden some components for your style – the CLI can fetch those if your registry is configured. (As a side note, the Shadcn team has discussed supporting multiple registries or themes in one project by listing them in components.json — e.g., an array of registries to search ￼ — but the current stable approach is to use one primary style registry at a time.)

For theme items, the CLI currently treats them as augmentations. You don’t specify a theme in components.json; instead, you add a theme by running a CLI command to include it (similar to adding a component). For example, after initializing, you might do shadcn add custom-theme. The CLI will pull in the theme’s variables and integrate them. Under the hood, this likely updates your globals.css or creates a theme CSS file. You might see the CLI output mention updating your Tailwind config or CSS files when adding a theme. It’s then up to you to use that theme – typically by toggling a class or data attribute on the <html> (for dark mode, Shadcn toggles the .dark class). If you have multiple themes (beyond light/dark), you’d similarly need to implement a mechanism to swap the CSS variables (for example, wrapping your app in a provider that switches the CSS variables based on user selection, which could be done by replacing the values at runtime or by swapping a class like data-theme="custom-theme" on a higher-level element). The Shadcn CLI doesn’t provide a full theme-switcher implementation out of the box – it provides the design tokens and CSS, and you handle the switching logic with something like next-themes or a custom solution.

Finally, be mindful of CLI version compatibility. If you’re using cutting-edge features (like a newly introduced theme or style item), ensure your shadcn CLI is up-to-date. The project’s changelog and discussions sometimes note improvements (for example, better error handling in registries, monorepo support, etc. as the registry feature evolved) ￼ ￼. Keeping the CLI updated will ensure it recognizes your registry:theme items and any new schema fields. The CLI is what reads your registry JSON and turns it into code, so any misalignment between your registry and CLI expectations can cause issues. In practice, sticking to the documented patterns (inline JSON items for themes and styles, proper naming, etc.) and using the latest CLI should result in a smooth experience where your custom themes and styles are applied as intended.

Pros and Cons Summary

To summarize the approaches:
	•	Inline Definition (Recommended): Define registry:style and registry:theme items in full within their JSON. Pros: Schema-compliant and validated (avoids “value not accepted” errors), straightforward for the CLI to consume, easier to share one-file-per-item, and clear organization (all relevant info in one place) ￼ ￼. Cons: JSON files can be lengthy for large themes, and shared data would need to be duplicated across items if not inherited. Overall, this approach is favored by official examples and reduces guesswork.
	•	External File Reference (Not officially supported for themes/styles): Attempt to split theme/style data into a separate file referenced via files[]. Pros: Could conceptually allow reusing a theme JSON in multiple styles or keep main item definitions shorter. Cons: Runs into schema limitations (the registry expects files to be code or static assets, not registry JSON) leading to validation errors or required kludges (like using registry:file with dummy targets) ￼ ￼. It adds complexity and isn’t demonstrated in docs, so it may break CLI assumptions. The maintenance burden and risk of errors (like improper variable injection or the CLI ignoring the file) outweigh the theoretical benefits.

Recommended pattern: Use inline definitions for both theme and style items, and leverage the registry’s dependency mechanisms instead of file indirection. For example, if your style needs to include a set of components or even a base theme, list those in registryDependencies by name or URL ￼ – this is how you can pull in, say, a base component library or an official theme preset, without manually copying files. This keeps everything declarative. In your project’s components.json, set the "style" to your custom style’s name ￼ before running the CLI. Then run shadcn init to scaffold the project. If you have a custom theme, add it with shadcn add as a separate step. This way, the CLI knows about your style from the start (ensuring all generated components use the right classes and variables), and your theme layers on afterward to customize colors. By following this pattern, you’ll avoid the common pitfalls and make the most of Shadcn UI’s registry system, achieving a themeable, maintainable component library with minimal friction ￼ ￼.

Sources:
	- https://ui.shadcn.com/docs/registry/examples (look for Custom style that extends shadcn/ui
  and Custom Theme Variables)
)
	- 